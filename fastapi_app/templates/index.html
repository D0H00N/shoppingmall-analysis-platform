<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>리뷰 분석 시스템</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body { 
            font-family: Arial, sans-serif; 
            background-color: #f4f4f4; 
            text-align: center; 
            justify-content: center; 
            margin: 0; /* 기본 여백 제거 */
            overflow-y: scroll;
            overflow-x: hidden; /* 🔹 가로 스크롤 방지 */
        }
        content {
            justify-content: center; 
        }
        .header {
            background-color: #6200ea;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }
        .search-container {
            display: flex;
            justify-content: flex-start;
            margin: 20px;
            border-radius: 12px;
            margin: 8px auto;
            max-width: 1300px; /* 👉 카드 크기 균형 조정 */
            position: relative;
        }
        .search-container input {
            width: 400px;
            padding: 10px;
            font-size: 16px;
            border-radius: 20px;
            border: 1px solid #ccc;
            text-align: center;
        }
        .search-container button {
            padding: 10px 20px;
            font-size: 16px;
            margin-left: 10px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
        }
        .container {
            /* text-align: center; */
            margin-bottom: 10px; /* ✅ 간격 줄이기 */
        }
        .box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .full-width {
            grid-column: span 2;
        }
/*/////////////////////////////////////////////////////////////////////////////            
        ///////////* 브랜드,제품 순위//////////////*/
        /* 카드 전체 스타일 */
        .ranking-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin: 8px auto;
            max-width: 1300px; 
            position: relative;
        }
        /* ✅ 브랜드,제품 순위 레이아웃 */
        .ranking-box {
            background: white;
            border-radius: 12px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);            
            display: grid;
            grid-template-columns: 1fr 1fr; /* 2개씩 배치 */
            grid-template-rows: 1fr; /* 2행 배치 */
            gap: 10px; /* 간격 최소화 */
            max-width: 1300px;
            margin: auto;
        }

        /* ✅ 차트 컨테이너 크기 최적화 */
        .ranking-container {
            background: white;
            padding: 0px; /* 기존 15px에서 줄임 */
            border-radius: 10px;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1);
            min-height: 450px !important;  /* 모든 차트 컨테이너 동일한 높이 */
            display: flex;
            flex-direction: column;
            justify-content: center; /* 중앙 정렬 */
            align-items: center;
            width: 100%; /* 너비 동일하게 설정 */
        }

        
        /* ✅ 개별 차트 내부 제목 */
        .ranking-container h4 {
            margin-bottom: 0px !important; /* 기존 10px → 3px */
            font-size: 16px;
            text-align: center;
        }
        /*///////////// 브랜드,제품 순위//////////////*/
        .sales-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin: 8px auto;
            max-width: 1300px; 
            position: relative;
            transition: transform 0.2s ease-in-out;
        }
        .sales-card:hover {
            transform: translateY(-3px);
        }
        .sales-box {
            display: flex; /* Flexbox로 변경 */
            justify-content: space-between; /* 차트들을 중앙 정렬 */
            gap: 15px; /* 차트 간 간격 */
            flex-wrap: wrap; /* 화면 크기에 따라 차트가 줄바꿈될 수 있도록 설정 */
            background: white;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            width: 100%;
        }

        /* ✅ 차트 컨테이너 크기 최적화 */
        .sales-container {
            flex: calc(33.33% - 20px); /* 각 차트 컨테이너의 크기 계산 */
            min-width: 280px; /* 최소 너비 설정 */
            text-align: center;
            background: white;
            padding: 12px;
            min-height: 250px; /* 최소 높이 설정 */
            max-height: 380px;
            border-radius: 10px;
            box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.1); 
        }
        
        /* ✅ 개별 차트 내부 제목 */
        .sales-container h4 {
            margin-bottom: 0px !important; /* 기존 10px → 3px */
            font-size: 16px;
            text-align: center;
        }
        /* ✅ 날짜 필터는 오른쪽 상단에 고정 */
        /* ✅ 날짜 필터를 오른쪽으로 완전히 정렬 */
        .date-filter {
            position: absolute;
            right: 20px;  /* 오른쪽 상단에 고정 */
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .date-filter input {
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .date-filter button {
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }
        .date-filter button:hover {
            background: #45a049;

        }
        /*//////////// 판매량 분석 보기//////////*/
        .hidden {
            display: none; /* 콘텐츠를 화면에서 숨김 */
        }
        .sales-button {
            position: absolute;
            left: 20px;
        }
        /* 버튼 스타일 */
        #toggleAnalysisButton {
            padding: 8px 14px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            left: 20px;
        }

        #toggleAnalysisButton:hover {
            background-color: #0056b3; /* 호버 시 색상 변경 */
        }

/*////////////////////////////////////////////////////////*/
        /* ✅ 버튼 스타일 */
        .review-btn {
            padding: 8px 0;
            font-size: 14px;
            background: #007BFF;
            color: white;
            border: none;
            border-radius: 6px;
            width: 120px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;           /* ✅ 넘치는 텍스트 잘라냄 */
            text-overflow: ellipsis;    /* ✅ 말줄임표로 처리 */
            }

        button.review-btn.guideline-btn {
        white-space: nowrap;      /* 줄바꿈 방지 */
        padding: 10px 18px;       /* 버튼 여백 */
        font-size: 14px;
        width: 180px;             /* ✅ 넉넉하게 너비 확보 */
        max-width: 100%;          /* 반응형 대응 */
        text-align: center;
        }
        .review-btn:hover {
            background: linear-gradient(135deg, #0056b3, #003d80);
        }
        /* ✅ 반응형 최적화 */
        @media screen and (max-width: 600px) {
            .review-card {
                flex-direction: column;
                text-align: center;
            }
            .review-image {
                margin-right: 0;
                margin-bottom: 10px;
            }
            .review-content {
                align-items: center;
            }
            .review-btn {
                align-self: center; /* ✅ 작은 화면에서는 중앙 정렬 */
            }
        }
        .price {
            font-size: 16px;
            font-weight: bold;
            color: #d9534f;
        }
        /* 제목 스타일 */
        .chart-card h3 {
            display: flex;
            text-align: center;
            justify-content: center;
            gap: 20px;
        }

 
        .sales-chart {
            width: 100% !important;
            height: 350px !important; /* 기존 320px → 400px로 증가 */
            padding: 0px !important;
        }


/*/////////////////////////////////////////////////////////////////////////////        
        /* ✅ 감성 분석 섹션의 간격 증가 */
        .chart-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        /* 감성 분석 & 브랜드 분석 */
        
        .analysis-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 40px;
        }
       /*//////// 제품 검색 섹션 ///////*/
       .product-search-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin: 8px auto;
            max-width: 1300px; 
            position: relative;
        }
        .search-title {
            font-size: 20px;
            font-weight: bold;
            text-align: left;
            margin-bottom: 10px;
            margin-left: 10px;
        }
        .product-search-box {
            display: flex;
            justify-content: space-between; /* 양쪽 끝 정렬 */
            align-items: flex-start; /* 세로 정렬 설정 */
        }
        @media only screen and (max-width: 600px) {
        .product-search-box {
            flex-direction: column; /* 세로 배치로 변경 */
        }}

        .filter-box {
            position: fixed;
            text-align: center;
            width: 150px;
            background: white;
            padding-bottom: 20px;
            clear: both;      
            z-index: 100;
            top: 500px;   
            /*margin-right: 200px; */
            left: 8px;                 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);  /* 그림자 효과 추가 */
            border-radius: 8px; /* 모서리 둥글게 */
        }
        /* 화면 크기가 작아졌을 때 적용할 스타일 */
        @media screen and (max-width: 1900px) {
        .filter-box {
            position: static; /* 고정 위치 해제 */
            order: 0; /* flex 순서 조정 */
            /*margin: 20px 0; /* 여백 추가 */
            width: 25%;
            height: 100%;
            border-top: 1px solid #eee;
            padding-top: 20px; 
            max-height: 430px; /* 스크롤 영역 크기 제한 */
            /*order: 9999; flex 컨테이너 내에서 마지막에 배치 */
            box-sizing: border-box;
        }}
        @media screen and (max-width: 600px) {
        .filter-box {
            position: static; /* 고정 위치 해제 */
            order: 0; /* flex 순서 조정 */
            margin: 20px 0; /* 여백 추가 */
            width: 100%;
            border-top: 1px solid #eee;
            padding-top: 20px; 
            /*order: 9999; flex 컨테이너 내에서 마지막에 배치 */
            box-sizing: border-box;
        }}
        .search-button {
            width: 100px; 
            height: 40px; 
            text-align: center;
            padding: 0;
            font-size: 16px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
        }
        .product-list h2 {
            position: relative;
            top: 0;
            z-index: 10;
        }
        .product-list {
            width: 100%;
            position: sticky;
            order: 1; /* flex 순서 조정 */
            background-color: white;
            padding: 15px;
            max-height: 430px; /* 스크롤 영역 크기 제한 */
            border-radius: 10px;
            overflow-y: auto; /* 내부 스크롤 활성화 */
            box-sizing: border-box;
        }
        @media screen and (max-width: 1900px) {
        .product-list {
        width: 75%;
        position: sticky;
        order: 1; /* flex 순서 조정 */
        background-color: white;
        padding: 15px;
        border-radius: 10px;
        overflow-y: auto; /* 내부 스크롤 활성화 */
        box-sizing: border-box;
        }}  
        @media screen and (max-width: 600px) {
        .product-list {
        width: 100%;
        order: 1; /* flex 순서 조정 */
        background-color: white;
        padding: 15px;
        border-radius: 10px;
        overflow-y: auto; /* 내부 스크롤 활성화 */
        box-sizing: border-box;
        }}  
        .filter-button {
            width: 100%;
            margin-bottom: 10px;
            padding: 12px;
            font-size: 14px;
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 5px;
            text-align: left;
            font-weight: bold;
            cursor: pointer;
            position: relative;

        }
        .filter-button span.filter-selected {
            font-size: 12px;
            color: gray;
            position: absolute;
            bottom: 50%;
            right: 2px; /* 여백 조정 */
            transform: translateY(50%);
            text-align: right;
        }
        .filter-selected {
            font-size: 12px;
            color: gray;
            position: absolute;
            bottom: 1px;
            left: 10px;
        }
        .filter-options {
            display: none;
            position: absolute;
            width: 100%;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
        
        }
        @media screen and (max-width: 1900px) {
        .filter-options {
            display: none;
            position: absolute;
            width: 25%;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }}
        @media screen and (max-width: 600px) {
        .filter-options {
            display: none;
            position: absolute;
            width: 95%;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }}
        

        /* 필터 옵션 강조 */
        .filter-options label {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        } 
        /* 한 번에 하나의 옵션만 열리도록 설정 */
        .filter-box.active .filter-options {
            display: block;
        }
        /* "제품 찾기" 제목 왼쪽 정렬 */
        .product-list h2 {
            text-align: left;
            margin-left: 20px;
        }    
        /* 제품 카드 스타일 */
        .product-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: #fafafae8; /* 연한 회색 배경 */
        border-radius: 5px;
        padding: 5px;
        margin-bottom: 5px;
        width: 95%;
        margin: 5px auto;
        margin-left: 0;
        gap: 8px;
        }
        .product-image {
            width: 120px;
            height: 120px;
            object-fit: cover;
            border-radius: 10px;
            border: 1px solid #ddd;
        }     
        .product-info-text {
            font-size: 14px;  /* ✅ 기본 텍스트 크기 */
            line-height: 0.8;
            font-weight: normal;
        }
        /* 제품 정보 텍스트 스타일 */
        .product-info {
            text-align: left;
            font-size: 14px;
            flex-grow: 1;
            margin-left: 15px;
            line-height: 1.2;
        }
        .product-info-text strong {
            font-size: 13px;  /* ✅ 제목(카테고리, 성별 등) 크기 작게 */
            font-weight: normal;  /* ✅ 기본 글씨체 유지 */
            color: #555;  /* ✅ 연한 회색으로 조정 */
        }
        .product-info-text span {
            font-size: 16px;  /* ✅ 실제 값(구두, 공용 등) 더 크게 */
            font-weight: bold;
            color: #222;  /* ✅ 강조 효과 */
        }
        #product-name {
            font-size: 17.5px;  /* ✅ 더 크게 */
            font-weight: bold;
            color: rgb(49, 165, 14);
        }
        #product-info {
            flex-grow: 0;  /* ✅ 자동 확장 방지 */
            width: 580px;  /* ✅ 너비 고정 */
            text-align: left;
            margin-right: auto; /* 🔥 왼쪽 정렬되도록 변경 */
        }
/*//////////////////////////////////////////////////////////////////////////*/


        /* ✅ "이상 감지 리뷰 목록" 섹션을 좀 더 위로 */
        .anomaly-section {
            margin-top: 30px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.1);
        }

        .review-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
        }

        
        /* 리뷰 카드 */
        .review-card {
            display: flex;
            align-items: center;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin-bottom: 12px;
            transition: transform 0.2s ease-in-out;
            gap: 15px; /* ✅ 요소 간격 균일 */
        }


        /* ✅ 마우스를 갖다댈 때 툴팁 표시 */
        .review-card:hover .product-tooltip {
            visibility: visible;
            opacity: 1;
        }
        .review-card:hover {
            transform: translateY(-3px);
        }
        .product-tooltip {
            position: absolute;
            bottom: 100%; /* ✅ 부모 컨테이너 위쪽으로 이동 */
            left: 50%;
            transform: translateX(-50%); /* ✅ 가운데 정렬 */
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 5px;
            white-space: nowrap;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        /* ✅ 이미지 크기 및 정렬 */
        .review-image {
            width: 80px; /* ✅ 동일한 크기로 조정 */
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid #ddd;
            flex-shrink: 0; /* ✅ 이미지 크기 유지 */
        }

        /* ✅ 리뷰 내용 스타일 */
        .review-content {
            display: flex;
            flex-direction: column;
            justify-content: center; /* ✅ 중앙 정렬 */
            gap: 5px;
            font-size: 14px;
            flex-grow: 1;
            text-align: left;
        }

        .review-title {
            font-size: 15px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            text-decoration: none;
        }
        .review-info {
            font-size: 14px;
            color: #666;
        }
        .review-text {
            font-size: 14px;
            color: #666;
            margin: 5px 0;
        }

        .review-meta {
            font-size: 13px;
            color: gray;
        }
        .chart-section {
            display: flex;
            flex-wrap: wrap;
            justify-content: center; /* ✅ 중앙 정렬 */
            align-items: center;
            gap: 20px;
        }

        .chart-section h2 {
            text-align: center; /* ✅ 제목을 중앙 정렬 */
            margin-bottom: 20px;
            font-size: 22px;
            width: 100%; /* ✅ 전체 너비 확보 */
        }
        .chart-box {
            flex: 1 1 33%; /* ✅ 한 줄에 3개 배치 */
            min-width: 320px; /* ✅ 최소 크기 설정 */
            max-width: 450px; /* ✅ 최대 크기 설정 */
            height: 400px; /* ✅ 동일한 높이 유지 */
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* ✅ 차트 내부 텍스트 넘침 방지 */
        }

        .bar-chart-box {
            flex: 1;
            min-width: 330px; /* ✅ 바 차트는 조금 더 넓게 설정 */
            max-width: 420px;
            height: 280px; /* ✅ 높이 조정 */
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
        }


        .toggle-btn {
            padding: 12px 20px;
            background: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 16px;
        }
        .toggle-btn:hover {
            background: #0056b3;
        }
        /* ✅ 알림 컨테이너 스타일 */
        /* ✅ 알림 컨테이너를 화면 우측 상단에 고정 */
        #notification-container {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 320px; /* 알림 크기 */
    max-width: 90vw;
    max-height: 400px; /* 최대 높이 설정 (스크롤 허용) */
    overflow-y: auto;
    display: flex;
    flex-direction: column-reverse;
    gap: 10px;
    z-index: 1000; /* 다른 요소 위에 표시 */
}
.mainPage-content {
    width: calc(100% - 17px);
}
/* ✅ 알림 스타일 */
.notification-popup {
    background: linear-gradient(135deg, #2c2c2c, #1a1a1a);
    color: white;
    border-radius: 10px;
    padding: 15px;
    box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.3);
    font-size: 14px;
    position: relative;
    width: 300px;
    max-width: 90vw;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.2s ease-in-out;
    transform: scale(0.95);
    border-left: 5px solid #ff4d4d;
    pointer-events: auto;
}



/* ✅ 제목 스타일 */
.notification-popup .title {
    font-size: 16px;
    font-weight: bold;
    color: #ff4d4d;
    display: flex;
    align-items: center;
    gap: 5px;
    text-align: center;
}

/* ✅ 감지 유형 강조 */
.anomaly-type {
    font-size: 14px;
    font-weight: bold;
    color: #ffd700; /* 노란색 강조 */
    display: block;
    margin: 5px 0;
}

/* ✅ 가격 정보 스타일 */
.notification-popup .price-info {
    font-size: 14px;
    color: #ddd;
    display: flex;
    align-items: center;
    gap: 5px;
}

/* ✅ 리뷰 스타일 */
.notification-popup .review {
    font-size: 14px;
    font-style: italic;
    color: #eee;
    border-left: 3px solid #ff4d4d;
    padding-left: 10px;
    margin: 10px 0;
}

/* ✅ 카테고리 & 평점 스타일 */
.notification-popup .meta-info {
    font-size: 13px;
    color: #bbb;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* ✅ 작성일 스타일 */
.notification-popup .date {
    font-size: 12px;
    color: #aaa;
    text-align: right;
    margin-top: 5px;
}

/* ✅ 닫기 버튼 스타일 */
.notification-popup .close-btn {
    position: absolute;
    top: 8px;
    right: 12px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    color: #ff4d4d;
    transition: color 0.2s ease-in-out;
}

.notification-popup .close-btn:hover {
    color: #d9534f;
}

/* ✅ 애니메이션 */
.notification-popup.show {
    opacity: 1;
    transform: translateY(0);
}
        .chart-group {
            display: flex;
            justify-content: center; /* ✅ 중앙 정렬 */
            flex-wrap: wrap; /* ✅ 자동 줄바꿈 */
            gap: 20px; /* ✅ 차트 간격 증가 */
            width: 100%;
            max-width: 1400px; /* ✅ 최대 너비 제한 */
            margin: 0 auto; /* ✅ 왼쪽/오른쪽 자동 여백 추가 */
        }
        h2 {
            width: 100%; /* 너비 전체 차지 */
            text-align: center; /* 중앙 정렬 */
            /*margin: 30px 0 15px 0; /* 위아래 여백 추가 */
            font-size: 22px; /* 글씨 크기 조정 */
            font-weight: bold; /* 글씨 두께 조정 */
        }
        /* 모달 창 디자인 */
        #reviewModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 480px;
            max-width: 90%;
            max-height: 75%;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }
        /* ✅ 모달 헤더 스타일 */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .modal-header h3 {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        #modalTitle {
            font-size: 18px;
            font-weight: bold;
        }

        /* ✅ 오른쪽 상품 추천 섹션 */
        .recommendation-section {
            flex: 2; /* ✅ 차트보다 좁게 설정 */
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        /* ✅ 리뷰 박스 스타일 */
        .review-box {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }

        /* ✅ 리뷰 아이템 스타일 */
        .review-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #444;
        }
        
        .sentiment-negative {
            color: red;
            font-weight: bold;
        }

        .sentiment-neutral {
            color: orange;
            font-weight: bold;
        }

        .sentiment-positive {
            color: green;
            font-weight: bold;
        }

        /* 브랜드 분석 평가 섹션 (검색창 포함) */
        .brand-analysis-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 20px;
            gap: 20px;
            flex-wrap: wrap; /* ✅ 반응형 대응 */
        }

        .brand-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0px 3px 6px rgba(0, 0, 0, 0.15);
            padding: 15px;  /* ✅ 여백 줄이기 */
            margin: 8px auto;
            max-width: 1300px; /* ✅ 기존 설정 유지 */
            position: relative;
            transition: transform 0.2s ease-in-out;
        }
        .brand-card:hover {
            transform: translateY(-3px);
        }
        .analysis-section {
            flex: 1;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }
        
        /* 불필요한 배경 및 박스 스타일 제거 */
        .analysis-section .box {
            background: transparent !important; /* ✅ 배경 완전 투명 */
            padding: 0 !important; /* ✅ 내부 여백 제거 */
            margin: 0 !important; /* ✅ 외부 여백 제거 */
            border: none !important; /* ✅ 테두리 제거 */
            box-shadow: none !important; /* ✅ 그림자 제거 */
            display: inline; /* ✅ 박스가 글씨 크기에 맞도록 설정 */
            font-size: 24px; /* ✅ 글씨 크기 조정 */
            font-weight: bold; /* ✅ 굵은 글씨 유지 */
            line-height: 1; /* ✅ 줄 간격 최소화 */
        }
        
        /* 그래프 컨테이너 */
        .graph-container {
            display: flex;
            justify-content: space-between; /* 왼쪽과 오른쪽 정렬 */
            align-items: stretch; /* ✅ 모든 박스 높이를 동일하게 조정 */
            gap: 20px;
            margin-top: 20px;
        }
        .graph-container h3{
            font-size:16px;
        }
        /* 왼쪽에 위치한 토픽별 만족도 & 언급량 */
        .graph-box {
            flex: 1; /* 동일한 너비 차지 */
            background-color: #ffffff !important; /* ✅ 흰색 배경 */
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            min-width: 250px;
        }

        /* 왼쪽 영역: 토픽별 만족도 & 언급량 */
        .graph-left {
            background-color: #ffffff !important; /* ✅ 흰색 배경 */
            display: flex;
            /* flex-direction: row; ✅ 가로 정렬 적용 */
            gap: 20px;
            flex: 1;
        }

        /* 오른쪽 영역: 브랜드 종합 평가 */
        .chart-right {
            background-color: #ffffff !important; /* ✅ 흰색 배경 */
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 20px;
            /* width: 100px; */
        }

        /* 브랜드 분석 평가 바 */
        .bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            min-height: 20px; /* ✅ 최소 높이 유지 */
        }

        .bar-label {
            width: 120px;
            text-align: right;
            font-size: 13px;
            margin-right: 10px;
        }

        .bar-wrapper {
            flex: 1;
            position: relative;
            height: 18px;
            background-color: transparent;  /* ✅ 회색 제거 */
            border-radius: 8px;
        }
        
        .background-bar {
            width: 100%;
            height: 100%;
            background-color: transparent;  /* ✅ 회색 제거 */
            border-radius: 8px;
            position: absolute;
        }

        /* ✅ "토픽별 언급량" 전용 스타일 */
        .background-bar-sentiment {
            display: flex;  /* ✅ flex 사용하여 비율대로 정렬 */
            justify-content: flex-start;  /* ✅ 왼쪽부터 정렬 */
            width: 100%;
            height: 20px;
            border-radius: 10px;
            overflow: hidden; /* ✅ 바들이 넘치지 않도록 설정 */
        }

        .bar {
            height: 100%;
            border-radius: 8px;
            transition: width 1.5s ease-in-out;
        }

        .bar-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: rgb(0, 0, 0);
            font-weight: bold;
            font-size: 12px;
        }

        .bar-text-sentiment { 
            position: absolute;
            color: black; /* ✅ 검정색 글씨 */
            font-weight: bold;
            font-size: 12px;
            white-space: nowrap; /* ✅ 텍스트가 줄 바꿈되지 않도록 설정 */
        }
        .gauge-container {
            width: 140px;
            height: 70px;
            position: relative;
            margin: auto;
            display: inline-block;
            justify-content: center;
            align-items: center;
        }

        .gauge-svg {
            overflow: visible;
        }

        .gauge-background {
            fill: none;
            stroke: #e0e0e0;
            stroke-width: 16; /* ✅ 배경 두께 조정 */
        }

        .gauge-fill {
            fill: none;
            /* stroke: #dc3f0b; 기본값: 노란색 */
            stroke-width: 16;
            stroke-linecap: round;
            transition: stroke-dasharray 1s ease-in-out;
        }

        .gauge-rating {
            font-size: 14px;
            font-weight: bold;
            fill: #333; /* 등급 텍스트 색상 */
        }

        .gauge-text {
            font-size: 16px;
            font-weight: bold;
            fill: black;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        
        /* 검색창과 브랜드 종합 평가를 가로로 정렬 */
        .search-container-brand {
            display: flex;
            justify-content: space-between; /* ✅ 좌우 정렬 (종합 점수 왼쪽, 검색창+버튼 오른쪽) */
            align-items: center; /* ✅ 수직 정렬 */
            width: 100%;
            margin-bottom: 20px;
            /* gap: 20px; 검색창과 브랜드 종합 평가 사이 간격 추가 */
        }

        .search-box-brand {
            display: flex;
            align-items: center;
            gap: 10px; /* 검색창과 버튼 사이 간격 조정 */
            justify-content: flex-end; /* ✅ 오른쪽 정렬 */
            flex: 1;
        }

        .brand-search-container {
            position: relative;
            min-width: 250px; /* ✅ 최소 크기 설정 */
        }

        #brand-name {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border-radius: 20px;
            border: 1px solid #ccc;
            text-align: center;
        }

        #brand-suggestions {
            position: absolute;
            top: 100%; /* ✅ 검색창 바로 아래 정렬 */
            left: 0;
            width: 100%; /* ✅ 검색창과 동일한 너비 */
            background: white;
            border: 1px solid #ddd;
            border-top: none; /* ✅ 위쪽 테두리 제거 */
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); /* ✅ 그림자 추가 */
            display: none; /* 기본적으로 숨김 */
            z-index: 1000; /* ✅ 다른 요소 위에 표시 */
        }
        .search-box-brand input {
            width: 100%; /* ✅ 부모 너비를 따라감 */
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .search-box-brand button {
            padding: 12px 20px;
            font-size: 16px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
        }
        .guideline-card {
            padding: 24px;
            border-radius: 16px;
            background-color: #ffffff;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            max-width: 680px;
            margin: 0 auto;
            font-family: 'Pretendard', sans-serif;
            line-height: 1.8;
            font-size: 15.5px;
        }
        .guideline-header {
            text-align: center;
            margin-bottom: 24px;
        }
        .guideline-header h2 {
            font-size: 22px;
            font-weight: 700;
            color: #222;
            word-break: break-word;
            white-space: normal;
            line-height: 1.4;
        }
        .guideline-title {
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }

        .guideline-section {
            background-color: #f9f9f9;
            border-radius: 10px;
            padding: 16px 20px;
            margin-bottom: 20px;
            border-left: 4px solid #007acc;
        }

        .section-title {
            font-size: 17px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #005b9f;
        }

        .section-content {
            font-size: 15px;
            color: #333;
        }

        .guideline-card p:first-child {
            margin-top: 0;
        }

        .guideline-card strong {
            font-weight: 600;
            color: #000;
        }

            /* 🔹 브랜드 판매량 추이를 토픽별 언급량 옆으로 배치 */
        .graph-right {
            display: flex;
            gap: 20px;
        }

        /* 🔹 브랜드 종합 평가는 별도로 배치 */
        .chart-top {
            display: flex;
            justify-content: flex-start; /* ✅ 왼쪽 정렬 */
            align-items: center;
        }
        
        /* 브랜드 종합 평가 (위쪽에 배치) */
        /* 공통 박스 스타일 */
        .graph-box,
        .score-box {
            flex: 1; /* ✅ 동일한 너비 배분 */
            background-color: #ffffff !important; /* ✅ 하얀색 배경 */
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            min-width: 200px;
            box-shadow: 0px 3px 6px rgba(0, 0, 0, 0.15);
        }

        .score-box h3 {
            display: flex;
            align-items: center;
            justify-content: center; /* ✅ 중앙 정렬 */
            gap: 4px;
            font-size: 16px; /* ✅ 원하는 크기로 조정 */
            margin-bottom: 20px;  /* ✅ 글자와 그래프 사이 여백 추가 */
        }

        .graph-box h3 {
            margin-bottom: 15px; /* 기존보다 여백 추가 */
            /* padding-bottom: 5px; 필요하면 추가 */
        }

        .legend {
            font-size: 12px;
            margin-left: 15px;
            display: inline-flex;
            gap: 10px;
            vertical-align: middle;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-weight: bold;
            gap: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            display: inline-block;
            border-radius: 2px; /* ❌ 안 둥글게 - 네모박스 */
            /* box-shadow: 0 0 1px rgba(0, 0, 0, 0.2); (선택) 입체감 */
        }
        
        /* 브랜드 판매량 추이 (아래쪽에 배치) */
        .brand-sales-chart-container {
            width: 100%;
            max-width: 500px; /* 최대 너비 */
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .suggestions {
            position: absolute;
            top: 100%; /* ✅ 검색창 바로 아래 정렬 */
            left: 0;
            width: 100%; /* ✅ 검색창과 동일한 너비 */
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            display: none; /* 기본적으로 숨김 */
            z-index: 1000; /* ✅ 다른 요소 위에 표시 */
            border-radius: 8px;
        }


        .suggestion-item {
            padding: 10px;
            cursor: pointer;
            font-size: 14px;
        }

        .suggestion-item:hover {
            background: #f0f0f0;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
            pointer-events: none;
            white-space: nowrap;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        .tooltip-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .tooltip-icon {
        /* margin-left: 6px; */
        font-size: 12px;
        color: #555;
        }

        .tooltip-text {
        visibility: hidden;
        width: 220px;
        background-color: #333;
        color: #fff;
        text-align: left;
        border-radius: 6px;
        padding: 8px;
        font-size: 12px;

        position: absolute;
        z-index: 1;
        bottom: 125%; /* 아이콘 위에 표시 */
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        transition: opacity 0.3s;
        white-space: normal;
        }

        .tooltip-wrapper:hover .tooltip-text {
        visibility: visible;
        opacity: 1;
        }

        
        /* ✅ 모달 스타일 */
        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95); /* ✅ 살짝 흐린 배경 */
            backdrop-filter: blur(15px); /* ✅ 흐림 효과 추가 */
            width: 80%;
            max-width: 600px;
            padding: 20px;
            border-radius: 12px; /* ✅ 더 부드러운 곡선 */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); /* ✅ 그림자 강조 */
            z-index: 1000;
        }
        
        .modal-content {
            text-align: center;
        }
        .modal.show {
            display: block;
            visibility: visible;
            opacity: 1;
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;  /* ✅ 모달보다 살짝 낮은 값 */
            display: none;
        }
        
        /* 모달 닫기 버튼 */
        .close {
            position: absolute;
            top: 12px;
            right: 18px;
            font-size: 24px;  /* ✅ 크기 키움 */
            font-weight: bold;
            cursor: pointer;
            color: #ff4d4d; /* ✅ 닫기 버튼 강조 */
            transition: color 0.2s ease-in-out;
        }
        .close:hover {
            color: #d9534f;
        }
        /* ✅ 버튼 그룹 정렬 */
        /* ✅ 버튼 스타일 */
        .button-group {
        display: flex;
        justify-content: flex-start;  /* ← 왼쪽 정렬 */
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: nowrap;     /* ✅ 줄바꿈 방지 */
        }
        /* ✅ 버튼 스타일 */
        .btn {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s, box-shadow 0.2s;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1); /* 👉 버튼이 살짝 떠 보이게 */
        }
        .btn:hover {
            background: #0056b3;
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.15);
        }
        /* ✅ 감성 분석 카드 컨테이너 */
        .card-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        /* ✅ 감성 분석 개별 카드 */
        .card {
            width: 45%;
            padding: 20px;
            background: white;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            text-align: center;
        }
        /* ✅ 이상 감지 목록 모달 스타일 */
        #anomalyModal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: white;
            width: 60%;  /* ✅ 화면의 60% 크기 */
            max-height: 80vh;  /* ✅ 화면 높이의 80% 이상 커지지 않도록 설정 */
            padding: 20px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            overflow: hidden;  /* ✅ 모달 전체 스크롤 방지 */
        }

        /* ✅ 모달 내부 리스트 스크롤 가능하도록 설정 */
        #modalAnomalyList {
            max-height: 60vh;  /* ✅ 모달 내부 리스트 높이 제한 */
            overflow-y: auto;  /* ✅ 스크롤 필요 시 활성화 */
            padding-right: 10px;
        }
        .custom-chart-container {
            flex: 1 1 calc(33.33% - 20px);
            min-width: 280px; /* ✅ 기존보다 크기 줄이기 */
            text-align: center;
            background: white;
            padding: 12px;
            min-height: 250px; /* ✅ 최소 높이 설정 */
            border-radius: 10px;
            box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.1);
        }
        /* ✅ 차트 행 정렬 (간격 조정) */
        .custom-chart-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        /* ✅ 감성 분석 카드 스타일 (전체 카드 크기 확장) */
        /* ✅ 감성 분석 카드 크기 조정 (위쪽 카드와 동일한 크기) */
        .anomal-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0px 3px 6px rgba(0, 0, 0, 0.15);
            padding: 15px;  /* ✅ 여백 줄이기 */
            margin: 8px auto;
            max-width: 1300px; /* ✅ 기존 설정 유지 */
            position: relative;
            transition: transform 0.2s ease-in-out;
        }
        .anomal-card:hover {
            transform: translateY(-3px);
        }
        /* ✅ 제목과 버튼을 같은 줄에 배치 */
        /* 카드 헤더: 제목과 버튼을 같은 줄에 배치 */
        /* 카드 헤더 */
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        /* 제목이 중앙에 정확히 위치하도록 조정 */
        .card-header h2 {
            flex-grow: 1; /* 가변적인 너비 확보 */
            text-align: center;
            margin: 0;
            font-size: 24px; /* 제목 크기 조정 */
            font-weight: bold;
        }
        /* ✅ 차트 행 정렬 (간격 조정) */
        .custom-chart-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .custom-button-group {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        /* ✅ 차트 크기 자동 조정 */
        .custom-chart {
            width: 100% !important;
            height: 230px !important; /* ✅ 기존보다 약간 줄이기 */
        }
        /* 버튼이 오른쪽으로 정렬되도록 설정 */
        .card-buttons {
            position: absolute;
            right: 20px; /* 버튼을 오른쪽으로 정렬 */
        }
        /* ✅ 버튼 스타일 개선 */
        /* 버튼 크기 조정 (줄바꿈 방지) */
        /* 버튼 크기 조정 (줄바꿈 방지) */
        .card-buttons .btn {
            padding: 8px 14px;
            font-size: 14px;
            white-space: nowrap;
        }
        .card-buttons .btn:hover {
            background: #0056b3;
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.15);
        }
        .ranking-container ul {
            list-style: none;
            padding: 0;
            text-align: left;
        }
        .ranking-container ul li {
            padding: 5px 0;
            font-size: 14px;
            border-bottom: 1px solid #ddd;
        }
        /* ✅ 순위 컨테이너 스타일 */
        /* ✅ 순위 카드 (왼쪽 고정) */
        /* ✅ 순위 카드 기본 스타일 */
        .ranking-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1);
            min-width: 300px;
            max-width: 500px;
        }

/* ✅ 개별 순위 카드 */
        /* ✅ 순위 카드 (하나로 통합 & 2x2 그리드) */
        /* ✅ 개별 순위 카드 */
        /* ✅ 순위 리스트 스타일 */
            /* ✅ 순위 카드 크기 줄이기 */
    .ranking-section {
        width: 98%;
        min-height: 220px; /* ✅ 차트와 같은 높이로 맞춤 */
        padding: 8px;
        border-radius: 10px;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        justify-content: space-between; /* ✅ 내부 요소 균형 유지 */
        font-size: 14px; /* 폰트 크기도 조정 */
    }
    .flex-container {
        display: flex;
        justify-content: space-between; /* 좌우 정렬 */
        gap: 20px; /* 간격 조정 */
    }
    .ranking-section h4 {
        text-align: center;
        margin-bottom: 10px;
        font-size: 16px;
    }
        /* 순위 리스트 스타일 */
        .ranking-list {
            list-style: none;
            padding: 0;
            text-align: left;
            margin: 10px 0;
        }
            .ranking-list li {
        background: #f8f8f8;
        padding: 8px;
        border-radius: 6px;
        font-weight: bold;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
        font-size: 13px;
    }
        /* ✅ 강조 스타일 */
        .top-rank {
            color: #FFD700; /* 금색 */
            font-weight: bold;
        }
        .low-rank {
            color: #ff4d4d; /* 빨간색 */
            font-weight: bold;
        }
        /* ✅ 순위 항목 기본 스타일 */
.ranking-item {
    width: 90% !important;
    padding: 12px !important;
    margin: 6px auto !important;
    border-radius: 8px !important;
    font-weight: bold !important;
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    background: #ffffff !important;
    box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.1) !important;
    transition: transform 0.2s, box-shadow 0.2s, background 0.3s !important;
    cursor: pointer !important;
    color: black !important;
}

.ranking-item::before {
    display: inline; /* ✅ 혹시 hidden이면 변경 */
    content: "🏆"; /* ✅ 아이콘 강제 삽입 */
}

/* 마우스 올릴 때 효과 */
.ranking-item:hover {
    transform: scale(1.05);
    box-shadow: 3px 3px 12px rgba(0, 0, 0, 0.2);
}
/* ✅ 순위 리스트 */
.ranking {
    margin-bottom: 10px;
}

/* 상위 브랜드 스타일 */
.ranking-item.top {
    background: linear-gradient(135deg, #fff7c2, #ffdd57) !important;
    color: black !important;
}

/* 하위 브랜드 스타일 */
/* ✅ 하위 브랜드 스타일 */
.ranking-item.low {
    background: linear-gradient(135deg, #ffb6b6, #ff6b6b) !important;
    color: black !important;
}
/* ✅ 마우스 호버 효과 */
.ranking-item.top:hover {
    background: linear-gradient(135deg, #FFD700, #FFA500) !important;
    color: white !important;
}

/* 하위 브랜드 스타일 */
.ranking-item.low:hover {
    background: linear-gradient(135deg, #ff4d4d, #ff6666);
    color: white;
}
/* ✅ 숨김 처리 */
.hidden {
    display: none;
}

/* 버튼 스타일 */
.rank-toggle-btn {
    padding: 10px 15px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    margin: 5px;
    transition: background 0.3s, box-shadow 0.2s;
}

.rank-toggle-btn:hover {
    background: #0056b3;
}

.rank-toggle-btn.active {
    background: #004080;
}
/* ✅ 상위/하위 순위 스타일 */
.ranking-list li.top {
    background: linear-gradient(135deg, #FFD700, #FFA500);
    color: white;
}
.ranking-list li.low {
    background: linear-gradient(135deg, #ff4d4d, #ff6666);
    color: white;
}
/* ✅ 제목 & 날짜 필터 정렬 */
.chart-header {
    display: flex;
    justify-content: center;  /* 제목을 중앙 정렬 */
    align-items: center;
    position: relative;
    padding: 10px 20px;
}

/* ✅ "판매량 분석" 제목을 정확히 중앙에 배치 */
.chart-header h3 {
    font-size: 24px;
    font-weight: bold;
    margin: 0;
    white-space: nowrap;
}
#ws-status {
    display: none; /* 요소를 완전히 숨김 */
}
/* ✅ 제목과 조회 필터를 한 줄로 정렬 */
.anomal-card .title-filter-container {
    display: flex;
    justify-content: space-between; /* 👉 제목과 필터를 좌우 정렬 */
    align-items: center;
    margin-bottom: 10px; /* ✅ 차트와 간격 유지 */
}

/* ✅ 제목 스타일 */
.anomal-card h2 {
    font-size: 22px;
    font-weight: bold;
    margin: 0;
}

/* ✅ 조회 필터 스타일 */
.anomal-card .date-filter {
    display: flex;
    gap: 10px;
    align-items: center;
}

/* ✅ 드롭다운과 버튼 디자인 */
.anomal-card .date-filter select,
.anomal-card .date-filter button,
.anomal-card .date-filter input {
    padding: 8px 12px;
    font-size: 14px;
    border-radius: 5px;
    border: 1px solid #ccc;
    background: white;
}

/* ✅ 조회 버튼 디자인 */
.anomal-card .date-filter button {
    background: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.3s ease-in-out;
}

.anomal-card .date-filter button:hover {
    background: #388E3C;
}

/* ✅ 차트와 날짜 필터 사이 간격 조정 */
.anomal-card .custom-chart-row {
    display: flex;
    justify-content: space-between; /* 👉 차트 균형 있게 정렬 */
    align-items: stretch;
    padding-top: 5px;
}
/* ✅ 제목 + 날짜 필터를 같은 줄에 정렬 */
.header-container {
    display: flex;
    align-items: center;
    padding: 10px 20px;
    border-bottom: 1px solid #e0e0e0;
    position: relative; /* ✅ 제목 중앙 정렬을 위해 상대 위치 지정 */
    height: 50px; /* ✅ 높이 조정 */
}

/* ✅ 제목(h2)을 정확히 중앙에 배치 */
.header-container h2 {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    margin: 0;
    font-size: 22px;
    font-weight: bold;
    pointer-events: none; /* ✅ 제목이 클릭 이벤트를 가로채지 않도록 설정 */
}

/* ✅ 필터를 오른쪽 정렬 */
.filter-container {
    margin-left: auto; /* ✅ 오른쪽 끝으로 이동 */
    display: flex;
    gap: 10px;
    align-items: center;
    font-size: 14px;
    z-index: 1; /* ✅ 필터가 제목 위로 올라오도록 설정 */
}

/* ✅ 라벨과 드롭다운 정렬 */
.filter-container label {
    font-size: 14px;
    font-weight: bold;
    margin-right: 3px;
    white-space: nowrap;
}

/* ✅ 드롭다운 디자인 */
.filter-container select {
    padding: 5px 10px;
    font-size: 14px;
    border-radius: 5px;
    border: 1px solid #ccc;
    background: white;
    height: 34px; /* ✅ 드롭다운 높이 조정 */
}

/* ✅ 조회 버튼 디자인 */
.filter-container button {
    background: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.3s ease-in-out;
    padding: 5px 12px;
    border-radius: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 34px; /* ✅ 드롭다운과 높이 맞춤 */
    font-size: 14px;
    white-space: nowrap;
    z-index: 2; /* ✅ 버튼이 최상위로 오도록 설정 */
}

.filter-container button:hover {
    background: #388E3C;
}
/* 모달 전체 틀 */
#guidelineModal.modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    width: 80%;
    max-width: 700px;
    max-height: 80vh;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    overflow: hidden;
}

/* 모달 내부 본문 (스크롤 적용) */
.guideline-modal-body {
    padding: 20px;
    overflow-y: auto;
    max-height: 70vh;
    position: relative;
}

/* 닫기 버튼 */
.guideline-modal-body .close {
    position: absolute;
    top: 12px;
    right: 18px;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    color: #ff4d4d;
}
.guideline-modal-body .close:hover {
    color: #d9534f;
}
#resizeHandle {
  width: 16px;
  height: 16px;
  background: #ccc;
  position: absolute;
  right: 0;
  bottom: 0;
  cursor: se-resize;
  border-bottom-right-radius: 4px;
}
    </style>
</head>

{% extends "base.html" %}
{% block title %}메인 페이지{% endblock %}
{% block content %}

<div class="mainPage-content"> 
    <!-- <h2 style="margin-top: 30px;">리뷰 분석 메뉴</h2>

    <div class="grid">
        <div class="menu-box" onclick="navigateTo('/overall-analysis')">종합 평가</div>
        <div class="menu-box" onclick="navigateTo('/strength-weakness.html')">강/약점 제공</div>
        <div class="menu-box" onclick="navigateTo('/top-ranked')">선 순위 제공</div> -->
        <!-- <div class="menu-box" onclick="navigateTo('/size_analysis.html')">사이즈 분석</div> -->
        <!-- <div class="menu-box" onclick="navigateTo('/date_analysis.html')">날짜 분석</div>
        <div class="menu-box" onclick="navigateTo('/product-review')">제품 평가</div>
        <div class="menu-box" onclick="navigateTo('/brand-analysis')">브랜드 분석</div>
        <div class="menu-box" onclick="navigateTo('/anomaly-detection.html')">이상 감지 리뷰 분석</div>
    </div> -->

    <!-- <div class="search-container">
        <input type="text" placeholder="브랜드명을 입력하세요...">
        <button>검색</button>
    </div> -->
<!-- ############################################################################################ -->

    <!-- 🔹 판매량 추이 -->
    <!-- 🔹 판매량 분석 -->
    <div class="ranking-card">
        <div class="chart-header">   
            <h2>브랜드/제품 순위</h2>
        </div>

        <!-- ✅ 1x2 레이아웃 -->
        <div class="ranking-box">
            <!-- ✅ 브랜드 순위 & 제품 순위 나란히 배치 -->
                <div class="ranking-section">
                    <h4>브랜드 순위</h4>
                    <ul class="ranking-list" id="top-brands"></ul>
                    <h4>하위 브랜드</h4>
                    <ul class="ranking-list" id="bottom-brands"></ul>
                </div>
                <div class="ranking-section">
                    <h4>제품 순위</h4>
                    <ul class="ranking-list" id="top-products"></ul>
                    <h4>하위 제품</h4>
                    <ul class="ranking-list" id="bottom-products"></ul>
                </div>
        </div>
    </div>
    
    <div class="sales-card">
        <!-- ✅ 제목 & 날짜 필터 한 줄 정렬 -->
        <div class="chart-header">
            <h2>판매량 분석</h2>
            <!-- 버튼: 모달 열기 -->
            <div class="sales-button">
                <button id="toggleAnalysisButton" onclick="salesModal()">판매량 분석 리포트</button> 
            </div>
            <!-- 날짜 필터 -->
            <div class="date-filter">
                <input type="date" id="startDate">
                <input type="date" id="endDate">
                <button onclick="loadCharts()">조회</button>
            </div>
        </div>   

        <!-- ✅ 판매량 추이 분석 모달 -->
        <div id="salesModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal('salesModal')">&times;</span>
                <h3 id="modalSalesTitle">판매량 추이 분석 내용</h3>
                <div id="modalSalesList">
                    <p>-------------------------------------------------------------------------------------------</p>
                    <p>참고 : 다른 연도 대비 2025년 데이터양이 적어서 그래프상 급감하고 있습니다. </p>
                    <p>-------------------------------------------------------------------------------------------</p>
                    <p>🔹전체 판매량 추이 분석🔹</p>
                    <p>2019년부터 점진적으로 판매량이 증가하다가 지금은 정체중입니다.</p>
                    <p>2023년 1월, 2024년 9월에 판매량 급감하였는데 원인 파악이 필요합니다.</p>
                    <p>-------------------------------------------------------------------------------------------</p>
                    <p>🔹 카테고리별 판매량 추이 분석🔹</p>
                    <p>여름 시즌 상품인 '샌들/슬리퍼'와 겨울 시즌 상품인 '구두'와 '부츠/워커'는 2023년 대비 2024년에는 판매량이 감소하였으니 공급량을 유지하는 것이 좋습니다.</p>
                    <p>'등산화'와 '트레킹화'는 판매량이 급격하게 증가하고 있는 인기 상품으로 공급량을 늘리는 것이 좋습니다.</p>
                    <p>-------------------------------------------------------------------------------------------</p>
                    <p>🔹 성별 판매량 추이 분석🔹</p>
                    <p>여성제품의 구매율이 2022년부터 급증하다 2024년엔 감소하였으니 공급량을 줄이는 것이 좋습니다.</p>
                    <p>남녀공용제품 구매율이 2020년부터 판매량이 급증하고 유지하고 있으니 공급량을 유지 또는 소폭 증가시키는 것이 좋습니다.</p>
                    <p>남성제품 구매율이 2021년부터 판매량이 점진적으로 증가하는 중이니 공급량을 늘리는 것이 좋습니다.</p>
                </div>
            </div>
        </div>



        <div class="sales-box">
                <!-- ✅ 전체 판매량 -->
            <div class="sales-container">
                <h4>전체 판매량 추이</h4>
                <canvas class="sales-chart" id="totalSalesChart"></canvas>
            </div>
                 <!-- ✅ 성별 판매량 -->
            <div class="sales-container">
                <h4>성별 판매량 추이</h4>
                <canvas class="sales-chart" id="genderSalesChart"></canvas>
            </div>
                <!-- ✅ 카테고리별 판매량 -->
            <div class="sales-container">
                <h4>카테고리별 판매량 추이</h4>
                <canvas class="sales-chart" id="categorySalesChart"></canvas>
            </div>
        </div>
    </div>     


<!-- 선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선 -->

<!-- ✅ 토글 방식으로 목록을 숨긴 상태에서 클릭 시 보이게 변경 -->
<!-- ✅ 감성 분석 카드 -->

    <span id="today_date" style="display: none;"></span>

    <!-- ✅ 오늘 감성 분석 -->
    <div class="anomal-card">
        <div class="card-header">
            <span id="ws-status">🔄 WebSocket 연결 상태 확인 중...</span>
            <h2>오늘 / 이번주 리뷰 분석</h2>
            <div class="card-buttons">
                <button id="today-btn" class="btn">오늘 이상 감지 목록</button>
                <button id="weekly-btn" class="btn">이번 주 이상 감지 목록</button>
            </div>
        </div>
        <div class="custom-chart-row">
            <div class="custom-chart-container">
                <h4>감성 비율</h4>
                <canvas class="custom-chart" id="stackedSentimentChart"></canvas>
            </div>
            <div class="custom-chart-container">
                <h4>리뷰 토픽별 언급량</h4>
                <canvas class="custom-chart" id="reviewTopicChart"></canvas>
            </div>
            <div class="custom-chart-container">
                <h4>평점 분포</h4>
                <canvas class="custom-chart" id="ratingDistributionChart"></canvas>
            </div>
        </div>
    </div>

    <div class="anomal-card">
        <!-- ✅ 제목 + 필터 -->
        <div class="header-container">
            <div style="margin-top: 4px; margin-bottom: 12px; text-align: right;">
                <button id="monthlyGuidelineBtn" class="btn btn-secondary">
                    월간 이상 감지 리포트
                 </button>
            </div>
            <h2>이상 감지 리뷰 및 제품 현황</h2>
            <div class="filter-container">
                <label for="yearSelect">연도:</label>
                <select id="yearSelect"></select>
    
                <label for="monthSelect">월:</label>
                <select id="monthSelect"></select>
    
                <button onclick="updateAnomalyTrend()">조회</button>
            </div>
        </div>
    
        <!-- ✅ 차트 -->
        <div class="custom-chart-row">
            <div class="custom-chart-container">
                <h4>이상 감지 추이</h4>
                <canvas class="custom-chart" id="anomalyTrendChart"></canvas>
            </div>
            <div class="custom-chart-container">
                <h4>카테고리별 이상 감지 분포</h4>
                <canvas class="custom-chart" id="shoesAnomalyChart"></canvas>
            </div>
            <div class="custom-chart-container">
                <h4>이상 감지된 제품 차트</h4>
                <canvas class="custom-chart" id="anomalyProductChart"></canvas>
            </div>
        </div>
    </div>
    

    <!-- ✅ 리뷰 상세보기 모달 -->
    <div id="reviewModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('reviewModal')">&times;</span>
            <h3 id="modalReviewTitle"></h3>
            <div id="modalReviewList"></div>
        </div>
    </div>

        <!-- ✅ 이상 감지 목록 모달 -->
    <div id="anomalyModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('anomalyModal')">&times;</span>
            <h2 id="modalAnomalyTitle">이상 감지 목록</h2>
            <div id="modalAnomalyList"></div>
        </div>
    </div>
    <div id="guidelineModal" class="modal">
        <div class="guideline-modal-body"> <!-- 기존 modal-content → 변경됨 -->
          <span class="close" onclick="closeGuidelineModal()">&times;</span>
          <div id="guidelineModalContent"></div>
        </div>
      </div>
      <!-- 🧠 월간 종합 가이드라인 전용 모달 -->
      <div id="monthlyGuidelineModal" class="modal">
        <div class="modal-content guideline-modal-body" id="monthlyGuidelineContentWrapper">
          <div class="modal-drag-header" id="monthlyGuidelineHeader">
            <span class="close" onclick="closeMonthlyGuidelineModal()">&times;</span>
          </div>
          <div id="monthlyGuidelineContent"></div>
      
          <!-- ✅ 크기 조절 핸들 (오른쪽 아래) -->
          <div id="resizeHandle"></div>
        </div>
      </div>
    <div id="notification" class="notification"></div>
    <!-- 선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선 -->

    <div class="brand-card">
        <!-- 브랜드 분석 평가 영역 전체 -->
        <div class="brand-analysis-header">
            <!-- 왼쪽: 종합 점수 -->
            <div class="score-box">
                <h3>종합 점수
                    <span class="tooltip-wrapper">
                        <span class="tooltip-icon">&#10068;</span>
                        <span class="tooltip-text">
                            1. 감성 점수를 0~100 범위로 변환<br>
                            2. 리뷰 개수 반영<br>
                            - 리뷰가 30개 미만이면 감점을 크게 (*0.7)<br>
                            - 100개 미만이면 *0.85, 300개 미만이면 *0.95<br>
                            - 300개 이상이면 감점 없음 (1.0)<br>
                            3. 최근 긍정 리뷰 비율 반영<br>
                            - 최근 긍정 리뷰 비율이 30% 미만이면 감점 (*0.85)<br>
                            - 30~50%이면 *0.95<br>
                            - 50% 이상이면 감점 없음 (1.0)<br>
                            4. 토픽별 최저 점수 반영<br>
                            - 특정 토픽 점수가 60 미만이면 감점 (*0.8)<br>
                            - 60~75면 *0.9<br>
                            - 75 이상이면 감점 없음<br>
                            5. 최종 브랜드 점수 계산
                        </span>
                    </span>
                </h3>
                <div class="gauge-container">
                    <!-- 👇 기존 gauge svg 그대로 사용 -->
                    <svg width="120" height="60" viewBox="0 0 140 70" class="gauge-svg">
                        <path d="M 10 60 A 50 50 0 0 1 130 60" class="gauge-background"/>
                        <path d="M 10 60 A 50 50 0 0 1 130 60" class="gauge-fill" id="brand-score-fill" stroke-dasharray="0, 251"/>
                        <text x="70" y="35" text-anchor="middle" class="gauge-rating" id="brand-score-rating">미흡</text>
                        <text x="70" y="50" class="gauge-text" id="brand-score-text">40점/100점</text>
                    </svg>
                </div>
            </div>

            <!-- 중앙: 타이틀 -->
            <div class="analysis-section">
                <strong>브랜드 분석 평가</strong>
            </div>

            <!-- 오른쪽: 검색창 + 버튼 -->
            <div class="search-box-brand">
                <div class="brand-search-container">
                    <input type="text" id="brand-name" placeholder="브랜드명을 입력하세요" autocomplete="off">
                    <div id="brand-suggestions" class="suggestions"></div>
                </div>
                <button onclick="fetchBrandAnalysis()">검색</button>
            </div>
        </div>

        <!-- 그래프 및 평가 UI -->
        <div class="graph-container">
            <!-- 왼쪽: 토픽별 만족도 & 토픽별 언급량 -->
            <div class="graph-left">
                <div class="graph-box">
                    <h3>토픽별 만족도</h3>
                    <div id="brand-score-results"></div>
                </div>
                
                <div class="graph-box">
                    <h3>
                        토픽별 언급량
                        <span class="legend">
                            <span class="legend-item">
                                <span class="legend-color" style="background-color: #187BCD;"></span>
                                긍정
                            </span>
                            <span class="legend-item">
                                <span class="legend-color" style="background-color: #8B5A2B;"></span>
                                중립
                            </span>
                            <span class="legend-item">
                                <span class="legend-color" style="background-color: #FF4D4D;"></span>
                                부정
                            </span>
                        </span>
                    </h3>
                    <div id="brand-frequency-results"></div>
                </div>
            </div>

            <!-- 브랜드별 판매량 추이를 토픽별 언급량 옆에 배치 -->
            <div class="graph-right">
                <!-- 브랜드 판매량 추이 -->
                <div class="score-box">
                    <div class="brand-sales-chart-container">
                        <h3>리뷰량 추이</h3>
                        <canvas id="brandSalesChart"></canvas>
                    </div>
                </div>
            </div>
        </div>        
    </div>

<!-- 선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선 -->
<!-- 🔹 제품 찾기 섹션 -->
    <div class="product-search-card">
    <!-- 왼쪽 검색 필터 -->
        <div class="product-search-box">
            <div class='filter-box'>
                <h2 class="search-title">제품 찾기</h2>

                <button class="filter-button" onclick="toggleFilter('topic')">
                    토픽 <span class="filter-selected" id="selected-topic"></span>
                </button>
                <div class="filter-options" id="filter-topic">
                    <label>토픽 선택:</label>
                    <select id="topic-select" onchange="updateFilterLabel('topic')">
                        <option value="">전체</option>
                        <option value="내구성 및 품질">내구성 및 품질</option>
                        <option value="디자인">디자인</option>
                        <option value="사이즈">사이즈</option>
                        <option value="가성비">가성비</option>
                        <option value="착용감">착용감</option>
                        <option value="배송 및 포장 및 응대">배송 및 포장 및 응대</option>
                    </select>
                </div>
        
                <button class="filter-button" onclick="toggleFilter('category')">
                    카테고리 <span class="filter-selected" id="selected-category"></span>
                </button>
                <div class="filter-options" id="filter-category">
                    <label>카테고리 선택:</label>
                    <select id="category-select" onchange="updateFilterLabel('category')">
                        <option value="">전체</option>
                        <option value="캔버스/단화">캔버스/단화</option>
                        <option value="구두">구두</option>
                        <option value="샌들/슬리퍼">샌들/슬리퍼</option>
                        <option value="힐">힐</option>
                        <option value="스포츠화">스포츠화</option>
                        <option value="부츠/워커">부츠/워커</option>
                        <option value="등산화">등산화</option>
                        <option value="트레킹화">트레킹화</option>
                    </select>
                </div>
        
                <button class="filter-button" onclick="toggleFilter('gender')">
                    성별 <span class="filter-selected" id="selected-gender"></span>
                </button>
                <div class="filter-options" id="filter-gender">
                    <label>성별 선택:</label>
                    <select id="gender-select">
                        <option value="공용">공용</option>
                        <option value="남자">남자</option>
                        <option value="여자">여자</option>
                    </select>
                </div>
        
                <button class="filter-button" onclick="toggleFilter('price')">
                    가격대 <span class="filter-selected" id="selected-price"></span>
                </button>
                <div class="filter-options" id="filter-price">
                    <input type="number" id="price-min">
                    <label> ~ </label>
                    <input type="number" id="price-max">
                </div>

                <button class="filter-button" onclick="toggleFilter('reviews')">
                    리뷰수 <span class="filter-selected" id="selected-reviews"></span>
                </button>
                <div class="filter-options" id="filter-reviews">
                    <label>최소 리뷰 수:</label>
                    <input type="number" id="min-reviews" value="50" min="0" onchange="updateFilterLabel('reviews')">
                </div>
        
                <!-- 검색 버튼을 필터 아래에 배치 -->
                <div class="filter-search-button">
                    <button class="search-button" onclick="fetchProductList()">검색</button>
                </div>
            </div>   
        
                <!-- 오른쪽 제품 목록 -->
            <div class="product-list">              
                <h2>검색 결과</h2>  
                <div id="product-results"></div>
            </div>
        </div>
    </div>
</div>

<!-- 스크립트스크립트스크립트스크립트스크립트스크립트/////////////////////////////////////////// -->
    <script>
        let totalSalesChart, categorySalesChart, genderSalesChart; // 차트 변수 선언

function salesModal() {
    const modal = document.getElementById("salesModal");
    
    // 현재 상태에 따라 보이거나 숨김 처리
    if (modal.style.display === "block") {
        modal.style.display = "none"; // 숨김 처리
    } else {
        modal.style.display = "block"; // 보임 처리
    }
}


// 날짜 분석 차트 //
async function fetchData(url) {
    try {
        const response = await fetch(url);
        console.log(`응답 상태 코드: ${response.status}`);
        console.log(`요청 URL: ${url}`);
        if (!response.ok) throw new Error(`API 요청 실패: ${url}`);
        const data = await response.json();
        console.log("응답 데이터:", data);
        return data;
    } catch (error) {
        console.error("데이터 로딩 오류:", error);
        return null;
    }
}

async function loadCharts() {
    const startDate = document.getElementById("startDate").value;
    const endDate = document.getElementById("endDate").value;

    // ✅ 날짜 값 확인

    try {
        // ✅ 기존 차트 제거
        if (totalSalesChart) totalSalesChart.destroy();
        if (categorySalesChart) categorySalesChart.destroy();
        if (genderSalesChart) genderSalesChart.destroy();

        // ✅ 병렬 API 호출로 데이터 불러오기 (최적화)
        const [totalSales, categorySales, genderSales] = await Promise.all([
            fetchData(`/api/total-sales?startDate=${startDate}&endDate=${endDate}`),
            fetchData(`/api/category-sales?startDate=${startDate}&endDate=${endDate}`),
            fetchData(`/api/gender-sales?startDate=${startDate}&endDate=${endDate}`)
        ]);

        if (totalSales) renderTotalSalesChart(totalSales);
        if (categorySales) renderCategorySalesChart(categorySales);
        if (genderSales) renderGenderSalesChart(genderSales);

    } catch (error) {
        console.error("🚨 차트 데이터 로딩 실패:", error);
        alert("데이터 로딩 중 오류가 발생했습니다.");
    }

    window.onload = function() {
        console.log(window.innerWidth);

        if(window.innerWidth >= 999) {
            Chart.defaults.font.size = 9;
        } else if(window.innerWidth >= 666 && window.innerWidth < 999) {
            Chart.defaults.font.size = 6;
        } else {
            Chart.defaults.font.size = 9;
        }
    }
}

//전체 제품 리뷰 그래프
function renderTotalSalesChart(data) {
    console.log("전체 판매량 차트 데이터:", data);
    const monthlyData = data.labels.reduce((acc, dateStr, index) => {
        const date = new Date(dateStr);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`; // "YYYY-MM" 형식으로 월별 키 생성
        acc[monthKey] = (acc[monthKey] || 0) + data.values[index]; 
        return acc;
    }, {});

    const sortedMonths = Object.keys(monthlyData).sort((a, b) => new Date(a) - new Date(b)); // 월을 오름차순으로 정렬
    const processedData = {
        labels: sortedMonths, // 월별 라벨 (YYYY-MM)
        values: sortedMonths.map(month => monthlyData[month]) // 월별 판매량
    };
    
    const ctx = document.getElementById("totalSalesChart")?.getContext("2d");
    if (!ctx) return;

    // ✅ 데이터셋 분리
    const totalSalesDataset = {
        label: "전체 판매량",
        data: processedData.values,
        borderColor: "rgba(72, 209, 204, 0.7)",
        backgroundColor: "rgba(72, 209, 204, 0.7)",
        borderWidth: 2,
    };


    totalSalesChart = new Chart(ctx, {
        type: "line",
        data: {
            labels: processedData.labels,
            datasets: [totalSalesDataset]
        },
        options: {
            plugins: {
                legend: {
                    labels: {
                        generateLabels: function(chart) {
                            return chart.data.datasets.map((dataset, i) => ({
                                text: dataset.label,
                                datasetIndex: i,
                                fillStyle: dataset.backgroundColor, // 색상 제거
                                strokeStyle: "transparent", // 텍스트 색상 유지
                                lineWidth: 0,  // ✅ 테두리 두께 유지
                                hidden: !chart.isDatasetVisible(i),
                                font: {size: 9,weight: 'bold', },
                            }));
                        }
                    },
                position: 'top'},
                tooltip: { mode: 'index', intersect: false },
            },             
            responsive: true,  // ✅ 자동 크기 조정 활성화
            maintainAspectRatio: false,  // ✅ 비율 유지
            tension: 0.4,
            fill: false,
            pointRadius: 0,         
            scales: {
                x: { 
                    type: "time", 
                    time: { unit: "year" }, 
                    grid: {display: false},
                    ticks: {font: {size: 11,weight: 'bold',}}
                },
                y: { 
                    beginAtZero: true, 
                    ticks: {font: {size: 11,weight: 'bold',}}
                }
            },
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            }
        }
    })
}


//카테고리별 리뷰 그래프
function renderCategorySalesChart(rawData) {
    const groupedData = groupDataByMonth(rawData);
    console.log("카테고리별 그룹화된 데이터:", groupedData);

    const ctx = document.getElementById("categorySalesChart")?.getContext("2d");
    if (!ctx) return;

    const labels = Object.keys(groupedData); // 월별 레이블 (YYYY-MM)
    console.log("차트 라벨:", labels);

    const categories = new Set();
    labels.forEach(month => {
        Object.keys(groupedData[month]).forEach(category => categories.add(category));
    });
    console.log("카테고리 목록:", categories);

    const datasets = [...categories].map(category => ({
        label: category,
        data: labels.map(month => groupedData[month][category] || 0),
        borderColor:  categoryColors[category] || "rgba(150, 150, 150, 0.7)",
        backgroundColor:  categoryColors[category] || "rgba(150, 150, 150, 0.7)",
        borderWidth: 2
    }));

    console.log("차트 데이터셋:", datasets);

    categorySalesChart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
            plugins: {
                legend: {
                    labels: {
                        generateLabels: function(chart) {
                            return chart.data.datasets.map((dataset, i) => ({
                                    text: dataset.label,
                                    datasetIndex: i,
                                    fillStyle: dataset.backgroundColor, // 색상 제거
                                    strokeStyle: "transparent", // 텍스트 색상 유지
                                    lineWidth: 0,  // ✅ 테두리 두께 유지
                                    hidden: !chart.isDatasetVisible(i),
                                    font: {size: 9,weight: 'bold', },
                            }))
                        }
                    },   
                position: 'top'},
                tooltip: { mode: 'index', intersect: false },
            },
            responsive: true,
            maintainAspectRatio: false,
            tension: 0.4,
            fill: false,
            pointRadius: 0,     
            scales: {
                x: { 
                    type: 'time',
                    time: { unit: 'year' }, 
                    grid: {display: false},
                    ticks: {font: {size: 11,weight: 'bold',} } },
                y: { 
                    beginAtZero: true,
                    ticks: {font: {size: 11,weight: 'bold',} } }
                    },
            interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
            }
        }
    })
};





function renderGenderSalesChart(rawData) {
  // ✅ 데이터 월별 집계
  const groupedData = groupDataByMonth(rawData);

  const ctx = document.getElementById("genderSalesChart")?.getContext("2d");
  if (!ctx) return;

  const labels = Object.keys(groupedData); // 월별 레이블 (YYYY-MM)
  const genders = new Set();
  
  // ✅ 성별 추출
  labels.forEach(month => {
    Object.keys(groupedData[month]).forEach(gender => genders.add(gender));
  });

  // ✅ 카테고리별 색상 매핑 (고정 색상 적용)
const genderColors = {
    "남자": "rgba(70, 130, 180, 0.7)",      
    "공용": "rgba(255, 140, 0, 0.7)",   
    "여자": "rgba(205, 92, 92, 0.7)"
};

  // ✅ 데이터셋 생성
  const datasets = [...genders].map(gender => ({
    label: gender,
    data: labels.map(month => groupedData[month][gender] || 0), // 해당 월의 성별 판매량
    borderColor: genderColors[gender] || "rgba(150, 150, 150, 0.7)",
    backgroundColor: genderColors[gender] || "rgba(150, 150, 150, 0.7)",
    borderWidth:2
  }));

  // ✅ 차트 생성
    genderSalesChart = new Chart(ctx, {
        type: "line",
        data: { labels, datasets },
        options: {
            plugins: {
                legend: {
                    labels: {
                        generateLabels: function(chart) {
                            return chart.data.datasets.map((dataset, i) => ({
                                    text: dataset.label,
                                    datasetIndex: i,
                                    fillStyle: dataset.backgroundColor, // 색상 제거
                                    strokeStyle: "transparent", // 텍스트 색상 유지
                                    lineWidth: 0,  // ✅ 테두리 두께 유지
                                    hidden: !chart.isDatasetVisible(i),
                                    font: {size: 9,weight: 'bold', },
                            }))
                        }
                    },
                position: 'top'},
                tooltip: { mode: 'index', intersect: false },
            }, 
            responsive: true,
            maintainAspectRatio: false,  
            tension: 0.4, // 곡선 정도
            fill: false, // ✅ 선 아래 영역 채우기 활성화
            pointRadius: 0, // ✅ 데이터 포인트 제거   
            scales: {
                x: {
                    type: "time",
                    time: { unit: "year" }, // ✅ x축을 월 단위로 표시
                    grid: {display: false}, // 세로축 안보이게
                    ticks: {font: {size: 11,weight: 'bold',padding:0} } }, // 라벨 폰트 사이즈,두께,
                y: {
                    beginAtZero: true,
                    ticks: {font: {size: 11,weight: 'bold'} } }
                    },
            interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
            }
        }
    })
};

    // ✅ 데이터 그룹화 함수 (월별 집계)
    function groupDataByMonth(data) {
    const grouped = {};

    Object.keys(data).forEach(date => {
        const month = date.slice(0, 7); // YYYY-MM 형식으로 변환
        if (!grouped[month]) grouped[month] = {};

        Object.entries(data[date]).forEach(([gender, count]) => {
        grouped[month][gender] = (grouped[month][gender] || 0) + count;
        });
    });

  console.log("그룹화된 월별 데이터:", grouped); // 디버깅용 로그 추가
  return grouped;
}
    function updateCommentBox(data) {
        const commentContent = document.getElementById("comment-content");
        console.log("📡 분석 데이터:", data);  // 🔍 서버 응답 데이터 확인
    
        if (!data || !data.product) {
            commentContent.innerHTML = "<p>분석 데이터를 불러오지 못했습니다.</p>";
            return;
        }
    
        // **🔥 최종 HTML 삽입 (스크롤 추가)**
        commentContent.innerHTML = `
            <div style="max-height: 200px; overflow-y: auto; text-align: left; padding: 10px;font-weight: bold;">
                <p>🔹 카테고리 별 추이 분석</p>
                <p>여름 시즌 상품 :샌들,슬리퍼 / 기준월: 6월,2017년부터 계속 증가하다가 2024년에는 감소</p>
                <p>겨울 시즌 상품 :구두 / 기준월: 12월,2019년부터 계속 증가하다가 2024년에는 감소</p>
            </div>
        `;
    }		
        



<!-- 선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선선 -->

// ==================================================================================================
document.getElementById("today_date").innerText = new Date().toISOString().slice(0, 10);

    let socket = null;
    let reconnectAttempts = 0;  
    const maxReconnectAttempts = 10;
    let lastData = null;
    let lastAnomalyData = null;

    // ✅ API에서 데이터 불러오기 및 차트 갱신
// ✅ API에서 데이터 불러오기 및 차트 갱신
async function fetchAnomalySummary() {
    // ✅ 전역 변수로 anomaly-summary 데이터 저장
    try {
        console.log("📡 데이터 갱신 요청...");
        // ✅ 마지막 업데이트 시간 가져오기 (로컬 상태 활용)
        const lastUpdate = localStorage.getItem("last_anomaly_update") || "";

        const response = await fetch('/api/anomaly-summary');
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

        const data = await response.json();
        console.log("📊 Anomaly Summary Data:", data);

        if (!data.today || !data.weekly) {
            throw new Error("❌ 이상 감지 데이터가 비어 있음");
        }

        // ✅ 최신 업데이트 시간 저장
        localStorage.setItem("last_anomaly_update", new Date().toISOString());

        // ✅ 중복 제거 (review_id + sentence 기준)
        data.today.anomaly_reviews = removeDuplicateReviews(data.today.anomaly_reviews);
        data.weekly.anomaly_reviews = removeDuplicateReviews(data.weekly.anomaly_reviews);

        lastAnomalyData = data; // ✅ 중복 제거된 데이터 저장

        console.log("✅ lastAnomalyData 업데이트 완료!", lastAnomalyData);
        console.log("📊 오늘 감성 분석 데이터:", data.today.sentiment_analysis);
        console.log("⚠️ 오늘 이상 감지 리뷰 개수:", data.today.anomaly_reviews.length);
        console.log("📌 오늘 부정 리뷰 개수:", data.today.negative_reviews.length);

        // updateDoughnutChart("todaySentimentChart", ["부정", "중립", "긍정"], [
        //     data.today.sentiment_analysis?.[0] || 0,
        //     data.today.sentiment_analysis?.[1] || 0,
        //     data.today.sentiment_analysis?.[2] || 0
        // ]);

        // updateDoughnutChart("weeklySentimentChart", ["부정", "중립", "긍정"], [
        //     data.weekly.sentiment_analysis?.[0] || 0,
        //     data.weekly.sentiment_analysis?.[1] || 0,
        //     data.weekly.sentiment_analysis?.[2] || 0
        // ]);
        // ✅ 기존 도넛 차트 호출 제거 (대신 스택형 막대 그래프 호출)
        updateStackedSentimentChart(
            "stackedSentimentChart",
            [
                data.today.sentiment_analysis?.[0] || 0,  // 오늘 부정
                data.today.sentiment_analysis?.[1] || 0,  // 오늘 중립
                data.today.sentiment_analysis?.[2] || 0   // 오늘 긍정
            ],
            [
                data.weekly.sentiment_analysis?.[0] || 0, // 이번 주 부정
                data.weekly.sentiment_analysis?.[1] || 0, // 이번 주 중립
                data.weekly.sentiment_analysis?.[2] || 0  // 이번 주 긍정
            ]
        );

        // ✅ 카테고리별 그래프 업데이트 (일일 & 주간)
        const todayCategoryKeys = Object.keys(data.today.category_analysis || {}).sort();
        const weeklyCategoryKeys = Object.keys(data.weekly.category_analysis || {}).sort();

        console.log("📌 정렬된 오늘 카테고리 키:", todayCategoryKeys);
        console.log("📌 주간 카테고리 키:", weeklyCategoryKeys);
        console.log("📌 주간 카테고리 데이터:", data.weekly.category_analysis);
        console.log("📌 주간 부정 카테고리 데이터:", data.weekly.negative_category_analysis);
        // 🚨 빈 배열이면 로그 출력
        if (weeklyCategoryKeys.length === 0) {
            console.error("🚨 주간 카테고리 키가 비어 있음. 데이터 문제 확인 필요!");
        }



        const allCategories = Array.from(new Set([
            ...Object.keys(data.today.category_analysis || {}),
            ...Object.keys(data.today.negative_category_analysis || {}),
            ...Object.keys(data.weekly.category_analysis || {}),
            ...Object.keys(data.weekly.negative_category_analysis || {})
        ])).sort();

        const negativeCategoryCounts = allCategories.map(cat => 
            data.today.negative_category_analysis?.[cat] ?? 0 // ✅ 없는 카테고리는 0으로 처리
        );

        // updateCombinedBarChart(
        //     "todayCombinedCategoryChart",
        //     allCategories,  // ✅ 전체 카테고리 리스트 (정렬된 상태)
        //     allCategories.map(cat => data.today.category_analysis?.[cat] ?? 0), // ✅ 전체 리뷰 개수 (없는 값은 0)
        //     negativeCategoryCounts // ✅ 부정 리뷰 개수 (없는 값은 0)
        // );

        // // ✅ 이번 주 카테고리별 데이터 업데이트 (순서 정렬)
        // updateCombinedBarChart("weeklyCombinedCategoryChart",
        //     weeklyCategoryKeys,
        //     weeklyCategoryKeys.map(cat => data.weekly.category_analysis?.[cat] ?? 0),
        //     weeklyCategoryKeys.map(cat => data.weekly.negative_category_analysis?.[cat] ?? 0)
        // );
        updateReviewTopicChart(
    "reviewTopicChart",
    allCategories,
    allCategories.map(cat => data.today.category_analysis?.[cat] ?? 0), // 오늘 전체 리뷰 개수
    allCategories.map(cat => data.weekly.category_analysis?.[cat] ?? 0), // 이번 주 전체 리뷰 개수
    allCategories.map(cat => data.today.negative_category_analysis?.[cat] ?? 0), // 오늘 부정 리뷰 개수
    allCategories.map(cat => data.weekly.negative_category_analysis?.[cat] ?? 0) // 이번 주 부정 리뷰 개수
);





updateRatingDistributionChart(
    "ratingDistributionChart",
    ["⭐ 1점", "⭐ 2점", "⭐ 3점", "⭐ 4점", "⭐ 5점"],
    [
        {
            label: "오늘 평점 분포",
            data: [
                data.today.rating_distribution?.[1] || 0,
                data.today.rating_distribution?.[2] || 0,
                data.today.rating_distribution?.[3] || 0,
                data.today.rating_distribution?.[4] || 0,
                data.today.rating_distribution?.[5] || 0
            ],
            backgroundColor: "rgba(54, 162, 235, 0.5)",
            borderColor: "rgba(54, 162, 235, 1)",
            fill: true
        },
        {
            label: "이번 주 평점 분포",
            data: [
                data.weekly.rating_distribution?.[1] || 0,
                data.weekly.rating_distribution?.[2] || 0,
                data.weekly.rating_distribution?.[3] || 0,
                data.weekly.rating_distribution?.[4] || 0,
                data.weekly.rating_distribution?.[5] || 0
            ],
            backgroundColor: "rgba(255, 99, 132, 0.5)",
            borderColor: "rgba(255, 99, 132, 1)",
            fill: true
        }
    ]
);


        console.log("📌 오늘 이상 감지 목록:", data.today.anomaly_reviews);
        console.log("📌 이번 주 이상 감지 목록:", data.weekly.anomaly_reviews);

        // ✅ 현재 열려 있는 모달 타입 확인 후 갱신
        const currentModalType = document.getElementById("modalAnomalyTitle").getAttribute("data-active");

        if (currentModalType === "today") {
            updateAnomalyReviews("today", lastAnomalyData.today.anomaly_reviews || []);
        } else if (currentModalType === "weekly") {
            updateAnomalyReviews("weekly", lastAnomalyData.weekly.anomaly_reviews || []);
        }

    } catch (error) {
        console.error("🚨 Error fetching anomaly summary:", error);
    }
}

function updateReviewTopicChart(canvasId, labels, todayData, weeklyData, todayNegative, weeklyNegative) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            labels,
            datasets: [
                {
                    label: "오늘 전체 리뷰",
                    data: todayData,
                    backgroundColor: "rgba(0, 128, 128, 0.3)",  
                    borderColor: "rgba(0, 128, 128, 0.8)",  
                    fill: true,
                    tension: 0.4
                },
                {
                    label: "이번 주 전체 리뷰",
                    data: weeklyData,
                    backgroundColor: "rgba(75, 192, 192, 0.2)",  
                    borderColor: "rgba(75, 192, 192, 0.8)",  
                    fill: true,
                    tension: 0.4
                },
                {
                    label: "오늘 부정 리뷰",
                    data: todayNegative,
                    backgroundColor: "rgba(255, 0, 0, 0.3)",  
                    borderColor: "rgba(255, 0, 0, 0.8)",  
                    fill: true,
                    tension: 0.4
                },
                {
                    label: "이번 주 부정 리뷰",
                    data: weeklyNegative,
                    backgroundColor: "rgba(255, 99, 132, 0.2)",  
                    borderColor: "rgba(255, 99, 132, 0.8)",  
                    fill: true,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    grid: { display: false },
                    ticks: { font: { size: 12, weight: 'bold' } }
                },
                y: {
                    beginAtZero: true,
                    grid: { borderDash: [3, 3] },
                    ticks: { font: { size: 14, weight: 'bold' } }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: false,  // ✅ 범례 아이콘을 사각형으로 유지
                        generateLabels: function (chart) {
                            return chart.data.datasets.map((dataset, i) => ({
                                text: dataset.label,
                                datasetIndex: i,
                                fillStyle: dataset.borderColor,  // ✅ 테두리 색상으로 내부 채우기
                                strokeStyle:"transparent",  // ✅ 테두리 유지
                                hidden: !chart.isDatasetVisible(i),
                                lineWidth: 2  
                            }));
                        }
                    }
                },
                tooltip: { mode: 'index', intersect: false },
                datalabels: { display: false }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
        },
        plugins: [ChartDataLabels]
    });
}



function updateRatingDistributionChart(canvasId, labels, datasets) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'bar',  // ✅ 막대 그래프 사용
        data: {
            labels: labels,
            datasets: [
                {
                    label: "오늘 평점 분포",
                    data: datasets[0].data,
                    backgroundColor: "rgba(0, 128, 128, 0.8)",  // ✅ 진한 청록색
                    borderColor: "rgba(0, 128, 128, 1)",
                    borderWidth: 1
                },
                {
                    label: "이번 주 평점 분포",
                    data: datasets[1].data,
                    backgroundColor: "rgba(75, 192, 192, 0.6)",  // ✅ 연한 청록색
                    borderColor: "rgba(75, 192, 192, 1)",
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    stacked: true,  // ✅ X축 누적 막대 설정
                    ticks: { font: { size: 12, weight: 'bold' } }
                },
                y: {
                    stacked: true,  // ✅ Y축 누적 설정 (각 막대가 누적됨)
                    beginAtZero: true,
                    grid: { borderDash: [3, 3] },
                    ticks: { font: { size: 14, weight: 'bold' } }
                }
            },
            plugins: {
                legend: { 
                    labels: {
                        generateLabels: function(chart) {
                            return chart.data.datasets.map((dataset, i) => ({
                                text: dataset.label,
                                datasetIndex: i,
                                fillStyle: dataset.backgroundColor, // 색상 제거
                                strokeStyle: "transparent", // 텍스트 색상 유지
                                lineWidth: 0,  // ✅ 테두리 두께 유지
                                hidden: !chart.isDatasetVisible(i),
                                font: {size: 9,weight: 'bold', },
                            }));
                        },
                    },
                display: true, 
                position: 'top' 
                },
                tooltip: { mode: 'index', intersect: false },
                datalabels: { display: false }  // ✅ 숫자 표시 제거
            },
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            }
        }
    });
}


    function updateNegativeReviews(reviews) {
        const reviewList = document.getElementById("negative-reviews");
        reviewList.innerHTML = "";

        reviews.forEach(review => {
            const listItem = document.createElement("li");
            listItem.innerHTML = `<span><strong>${review.category}</strong>: ${review.sentence}</span>`;
            reviewList.appendChild(listItem);
        });
    }
// ✅ 중복 리뷰 제거 함수 (review_id + sentence 기준)
function removeDuplicateReviews(reviews) {
    const seen = new Set();
    return reviews.filter(review => {
        const key = `${review.review_id}-${review.sentence.trim()}`; // ✅ 중복 기준: review_id + sentence
        if (seen.has(key)) {
            return false;
        }
        seen.add(key);
        return true;
    });
}

    // ✅ 전역 차트 인스턴스 저장 변수
let chartInstances = {};

// ✅ 기존 차트를 삭제하는 함수
function destroyAllCharts() {
    for (const canvasId in chartInstances) {
        if (chartInstances[canvasId]) {
            console.log(`🗑️ 기존 차트 삭제됨: ${canvasId}`);
            chartInstances[canvasId].destroy();  // ✅ 기존 차트 완전 삭제
            delete chartInstances[canvasId];  // ✅ 메모리 해제
        }
    }
}

// ✅ 연도 및 월 선택 드롭다운 생성
// ✅ 연도 및 월 선택 드롭다운 생성
function populateDateSelectors() {
    const yearSelect = document.getElementById("yearSelect");
    const monthSelect = document.getElementById("monthSelect");

    const currentYear = new Date().getFullYear();
    for (let year = currentYear; year >= 2023; year--) {
        const option = document.createElement("option");
        option.value = year;
        option.textContent = `${year}년`;
        yearSelect.appendChild(option);
    }

    for (let month = 1; month <= 12; month++) {
        const option = document.createElement("option");
        option.value = month;
        option.textContent = `${month}월`;
        monthSelect.appendChild(option);
    }

    yearSelect.value = currentYear;
    monthSelect.value = new Date().getMonth() + 1;
}

async function fetchAnomalyProducts(year, month) { 
    try {
        console.log(`📡 ${year}년 ${month}월 이상 감지 제품 목록 요청...`);
        const response = await fetch(`/api/anomaly-products/${year}/${month}`);
        const data = await response.json();

        if (!data || data.error || data.length === 0) {
            console.warn(`⚠️ ${year}년 ${month}월 이상 감지 제품 없음`);
            updateAnomalyProductChart(["데이터 없음"], [0], []);
            return;
        }

        console.log(`📊 ${year}년 ${month}월 이상 감지 제품 목록:`, data);

        // ✅ 제품 이름, 감지 횟수, 제품 ID 배열 생성
        const productNames = data.map(product => product.product_name);
        const anomalyCounts = data.map(product => product.anomaly_count);
        const productIds = data.map(product => product.product_id);

        updateAnomalyProductChart(productNames, anomalyCounts, productIds);

    } catch (error) {
        console.error(`🚨 ${year}년 ${month}월 이상 감지 제품 데이터를 불러오는 중 오류 발생:`, error);
    }
}

function updateAnomalyProductChart(productNames, anomalyCounts, productIds) {
    const canvasId = "anomalyProductChart";
    const canvas = document.getElementById(canvasId);

    if (!canvas) {
        console.warn(`⚠️ 차트 캔버스를 찾을 수 없음: ${canvasId}`);
        return;
    }

    const ctx = canvas.getContext("2d");

    // ✅ 기존 차트 삭제 (중복 생성 방지)
    if (window.chartInstances && window.chartInstances[canvasId]) {
        window.chartInstances[canvasId].destroy();
    }

    // ✅ 제품명을 8글자로 줄이는 함수 (Y축 전용)
    function shortenLabel(name, maxLength = 8) {
        return name.length > maxLength ? name.substring(0, maxLength) + "..." : name;
    }

    // ✅ 모든 막대를 연한 회색 계열로 설정
    const barColors = Array(productNames.length).fill("rgba(192, 192, 192, 0.7)"); // 연한 회색
    const borderColors = Array(productNames.length).fill("rgba(128, 128, 128, 1)"); // 중간 회색 테두리

    window.chartInstances[canvasId] = new Chart(ctx, {
        type: "bar",
        data: {
            labels: productNames.map(name => shortenLabel(name)), // ✅ 제품명 8글자 제한
            datasets: [{
                label: "이상 감지 횟수",
                data: anomalyCounts,
                backgroundColor: barColors,
                borderColor: borderColors,
                borderWidth: 1
            }]
        },
        options: {
            indexAxis: 'y',  
            responsive: true,
            maintainAspectRatio: false,
            onClick: (event, elements) => {
                console.log("📌 클릭 이벤트 발생!", event, elements);

                // ✅ 클릭한 요소가 있는지 확인
                if (!elements || elements.length === 0 || !elements[0]) {
                    console.warn("⚠️ 클릭한 요소가 감지되지 않음!");
                    return;
                }

                const index = elements[0].index;

                // ✅ 유효한 index인지 확인
                if (index === undefined || index < 0 || index >= productIds.length) {
                    console.warn(`⚠️ 유효하지 않은 index (${index})`);
                    return;
                }

                const selectedProductId = productIds[index];

                // ✅ 유효한 제품 ID인지 확인
                if (!selectedProductId) {
                    console.warn(`⚠️ 선택한 제품 ID가 존재하지 않음 (index: ${index})`);
                    return;
                }

                console.log(`🔍 선택한 제품 ID: ${selectedProductId}`);
                window.location.href = `/strength-weakness.html?product_id=${selectedProductId}`;
            },
            scales: {
                x: { 
                    grid: { display: true },
                    ticks: { font: { size: 12, weight: "bold" } }
                },
                y: { 
                    grid: { display: false },
                    ticks: {
                        font: { size: 12, weight: "bold" },
                        autoSkip: false
                    }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    mode: "nearest",
                    intersect: false
                }
            },
            barThickness: 20,  
            categoryPercentage: 0.8  
        }
    });
}



async function fetchAnomalyShoesCategory(year, month) {
    try {
        console.log(`📡 ${year}년 ${month}월 신발 카테고리별 이상 감지 데이터 요청...`);
        const response = await fetch(`/api/anomaly-shoes-category/${year}/${month}`);
        const jsonResponse = await response.json();

        console.log(`📊 API 응답:`, jsonResponse);

        const data = jsonResponse.data || [];

        if (!data.length) {
            console.warn(`⚠️ ${year}년 ${month}월 신발 카테고리 데이터 없음`);
            updateShoesAnomalyChart(["데이터 없음"], [0]); 
            return;
        }

        console.log(`📊 ${year}년 ${month}월 신발 카테고리별 데이터:`, data);

        const categories = data.map(item => item.category);
        const anomalyCounts = data.map(item => item.anomaly_count);
        updateShoesAnomalyChart(categories, anomalyCounts);

    } catch (error) {
        console.error(`🚨 ${year}년 ${month}월 신발 카테고리 데이터를 불러오는 중 오류 발생:`, error);
    }
}

// ✅ 카테고리별 색상 매핑 (고정 색상 적용)
const categoryColors = {
    "구두": "rgba(255, 99, 132, 0.7)",       // 빨강
    "부츠/워커": "rgba(255, 165, 0, 0.7)",   // 오렌지
    "샌들/슬리퍼": "rgba(75, 192, 92, 0.7)", // 초록
    "캔버스/단화": "rgba(54, 162, 235, 0.7)", // 파랑
    "스포츠화": "rgba(153, 102, 255, 0.7)", // 보라
    "드레스화": "rgba(255, 206, 86, 0.7)",  // 노랑
    "등산화": "rgba(0, 139, 139, 0.7)",      // 다크 청록
    "트래킹화": "rgba(128, 128, 128, 0.7)", // 회색
    "힐": "rgba(139, 69, 19, 0.7)"          // 갈색 (변경됨)
};

// ✅ 차트 업데이트 함수에서도 동일한 categoryColors 적용
function updateShoesAnomalyChart(categories, anomalyCounts) {
    const canvasId = "shoesAnomalyChart";
    const canvas = document.getElementById(canvasId);
    
    if (!canvas) {
        console.warn(`⚠️ 차트 캔버스를 찾을 수 없음: ${canvasId}`);
        return;
    }

    const ctx = canvas.getContext("2d");

    if (!window.chartInstances) {
        window.chartInstances = {};
    }

    // ✅ 카테고리 색상을 고정된 색상 매핑에서 가져옴
    const colors = categories.map(category => categoryColors[category] || "rgba(150, 150, 150, 0.7)");

    if (!window.chartInstances[canvasId]) {
        // ✅ 최초 실행 시 새 차트 생성
        window.chartInstances[canvasId] = new Chart(ctx, {
            type: "doughnut",
            data: {
                labels: categories,
                datasets: [{
                    label: "신발 카테고리별 이상 감지 횟수",
                    data: anomalyCounts,
                    backgroundColor: colors,  // ✅ 고정된 색상 적용
                    borderColor: colors,
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
					legend: {
                        labels: {
                            generateLabels: function(chart) {
                                return chart.data.labels.map((label, i) => ({
                                    text: label,  // ✅ 범례 텍스트 수정됨
                                    datasetIndex: 0,  // ✅ dataset은 1개
                                    fillStyle: chart.data.datasets[0].backgroundColor[i],
                                    strokeStyle: "transparent",
                                    lineWidth: 0,
                                    hidden: !chart.isDatasetVisible(0),
                                    font: { size: 9, weight: 'bold' }
                                }))        
                            }
                        },
                        display: true, 
                        position: "right" 
                    },
                    tooltip: { mode: "index", intersect: false }
                }
            }
        });
    } else {
        // ✅ 기존 차트 업데이트
        window.chartInstances[canvasId].data.labels = categories;
        window.chartInstances[canvasId].data.datasets[0].data = anomalyCounts;
        window.chartInstances[canvasId].data.datasets[0].backgroundColor = colors;
        window.chartInstances[canvasId].update();
    }
}




// ✅ 조회 버튼 클릭 시 데이터 불러오기
async function updateAnomalyTrend() {
    const selectedYear = document.getElementById("yearSelect").value;
    const selectedMonth = document.getElementById("monthSelect").value;

    console.log(`📡 ${selectedYear}년 ${selectedMonth}월 데이터 병렬 요청 시작...`);

    await Promise.all([
        fetchAnomalyTrend(selectedYear, selectedMonth),
        fetchAnomalyProducts(selectedYear, selectedMonth),
        fetchAnomalyShoesCategory(selectedYear, selectedMonth)
    ]);

    console.log(`✅ ${selectedYear}년 ${selectedMonth}월 데이터 병렬 요청 완료!`);
}



function updateLineChart(canvasId, labels, values) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
        console.warn(`⚠️ 차트 캔버스를 찾을 수 없음: ${canvasId}`);
        return;
    }

    const ctx = canvas.getContext('2d');
    
    // ✅ 기존 차트 삭제 (중복 생성 방지)
    if (window.chartInstances && window.chartInstances[canvasId]) {
        window.chartInstances[canvasId].destroy();
    }

    window.chartInstances = window.chartInstances || {}; // ✅ 전역 차트 저장 객체 생성

    window.chartInstances[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: '이상 감지 리뷰 수',
                data: values,
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                fill: true,
                tension: 0.4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { grid: { display: false }, ticks: { font: { size: 12, weight: 'bold' } } },
                y: { beginAtZero: true, ticks: { font: { size: 14, weight: 'bold' } } }
            },
            plugins: {
                legend: { display: true, position: 'top' },
                tooltip: { mode: 'index', intersect: false },
                datalabels: { display: false }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
        }
    });
}

async function fetchAnomalyTrend(year, month) {
    try {
        console.log(`📡 ${year}년 ${month}월 이상 감지 데이터 요청...`);
        const response = await fetch(`/api/anomaly-trend/${year}/${month}`);
        const data = await response.json();

        if (!data || data.error || data.length === 0) {
            console.warn(`⚠️ ${year}년 ${month}월 데이터 없음`);
            document.getElementById("anomalyTrendChart").innerHTML = "<p>⚠️ 데이터 없음</p>"; // 경고 메시지 표시
            return;
        }

        console.log(`📊 ${year}년 ${month}월 이상 감지 리뷰 데이터:`, data);

        const labels = data.map(item => item.date);
        const negativeCounts = data.map(item => item.negative_count);
        const lowRatingCounts = data.map(item => item.low_rating_count);

        updateAnomalyTrendChart("anomalyTrendChart", labels, negativeCounts, lowRatingCounts);
    } catch (error) {
        console.error(`🚨 ${year}년 ${month}월 이상 감지 리뷰 데이터를 불러오는 중 오류 발생:`, error);
    }
}

function updateAnomalyTrendChart(canvasId, labels, negativeCounts, lowRatingCounts) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
        console.warn(`⚠️ 차트 캔버스를 찾을 수 없음: ${canvasId}`);
        return;
    }

    const ctx = canvas.getContext('2d');

    // ✅ 기존 차트 삭제 (중복 생성 방지)
    if (window.chartInstances && window.chartInstances[canvasId]) {
        window.chartInstances[canvasId].destroy();
    }

    window.chartInstances = window.chartInstances || {};

    window.chartInstances[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: "부정 감성 리뷰",
                    data: negativeCounts,
                    borderColor: 'rgba(255, 140, 0, 1)',  // ✅ 진한 주황색 테두리
                    backgroundColor: 'rgba(255, 140, 0, 0.3)',  // ✅ 연한 주황색 영역
                    fill: true,
                    tension: 0.4
                },
                {
                    label: "평점 1~3 리뷰",
                    data: lowRatingCounts,
                    borderColor: 'rgba(147, 112, 219, 1)',  // ✅ 진한 보라색 테두리
                    backgroundColor: 'rgba(147, 112, 219, 0.3)',  // ✅ 연한 보라색 영역
                    fill: true,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { grid: { display: false }, ticks: { font: { size: 12, weight: 'bold' } } },
                y: { beginAtZero: true, ticks: { font: { size: 14, weight: 'bold' } } }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        generateLabels: function(chart) {
                            return chart.data.datasets.map((dataset, i) => ({
                                text: dataset.label,
                                datasetIndex: i,
                                fillStyle: dataset.borderColor,  // ✅ 범례 내부 색상을 테두리 색상과 동일하게 설정
                                strokeStyle: dataset.borderColor,  // ✅ 테두리도 동일한 색상 적용
                                lineWidth: 2,  // ✅ 테두리 두께 유지
                                hidden: !chart.isDatasetVisible(i)
                            }));
                        }
                    }
                },
                tooltip: { mode: 'index', intersect: false },
                datalabels: { display: false }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
        }
    });
}

function makeModalResizable(wrapperId, handleId) {
  const wrapper = document.getElementById(wrapperId);
  const handle = document.getElementById(handleId);

  let isResizing = false;

  handle.addEventListener("mousedown", function (e) {
    isResizing = true;

    const startX = e.clientX;
    const startY = e.clientY;
    const startWidth = parseInt(window.getComputedStyle(wrapper).width, 10);
    const startHeight = parseInt(window.getComputedStyle(wrapper).height, 10);

    function doDrag(e) {
      if (!isResizing) return;
      wrapper.style.width = (startWidth + e.clientX - startX) + "px";
      wrapper.style.height = (startHeight + e.clientY - startY) + "px";
    }

    function stopDrag() {
      isResizing = false;
      document.removeEventListener("mousemove", doDrag);
      document.removeEventListener("mouseup", stopDrag);
    }

    document.addEventListener("mousemove", doDrag);
    document.addEventListener("mouseup", stopDrag);
  });
}



// ✅ 페이지 로드 시 실행 (중복 제거)
document.addEventListener("DOMContentLoaded", () => {
    if (!window.isDOMContentLoaded) {
        window.isDOMContentLoaded = true;  // ✅ 중복 실행 방지

        console.log("📡 DOM 로드 완료, 필수 요소 확인 중...");
        const guidelineBtn = document.getElementById("monthlyGuidelineBtn");
        // const guidelineCard = document.querySelector(".guideline-card");
        if (guidelineBtn) {
            // guidelineCard.style.width = "460px"; // 원하는 크기
            guidelineBtn.addEventListener("click", async () => {
                const year = document.getElementById("yearSelect").value;
                const month = document.getElementById("monthSelect").value;

                const modal = document.getElementById("monthlyGuidelineModal");
                const content = document.getElementById("monthlyGuidelineContent");

                if (!modal || !content) {
                    console.error("🚨 월간 가이드라인 모달 요소를 찾을 수 없습니다.");
                    return;
                }

                modal.style.display = "block";
                content.innerHTML = `<p>🔄 ${year}년 ${month}월 가이드라인 생성 중입니다...</p>`;

                try {
                    const res = await fetch(`/api/anomaly-guideline-monthly/${year}/${month}`);
                    if (!res.ok) throw new Error("API 응답 실패");

                    const json = await res.json();
                    const guidelineText = json.guideline || "⚠️ 분석 결과 없음";

                    // ✅ 제품명 또는 제목 추출
                    const titleMatch = guidelineText.match(/📝\s*\[\s*([\s\S]*?)\s*\]/);
                    const title = titleMatch ? titleMatch[1].trim() : `${year}년 ${month}월 월간 이상 감지 리포트`;

                    // ✅ 📝 제거 및 텍스트 클린업
                    let body = guidelineText.replace(/📝\s*\[\s*([\s\S]*?)\s*\]/, "").trim();
                    body = body
                        .replace(/\*{0,2}제품\s*개선\s*가이드라인\*{0,2}/gi, "")
                        .replace(/\*{1,3}(.+?)\*{1,3}/g, "$1")
                        .trim();

                    const lines = body.split("\n").filter(line => {
                        const cleanLine = line.replace(/\s/g, "");
                        const cleanTitle = title.replace(/\s/g, "");
                        return !cleanLine.includes(cleanTitle);
                    });
                    body = lines.join("\n").trim();

                    // ✅ 섹션별로 나누기
                    const sectionBlocks = body.split(/\n(?=\d\.\s)/g);
                    const formattedSections = sectionBlocks.map(section => {
                        const lines = section.trim().split("\n");
                        const sectionTitle = lines[0].trim();
                        const sectionContent = lines.slice(1).join("<br>");
                        return `
                            <div class="guideline-section">
                                <div class="section-title">${sectionTitle}</div>
                                <div class="section-content">${sectionContent}</div>
                            </div>
                        `;
                    }).join("");

                    // ✅ 최종 렌더링 (기존 guideline 디자인과 동일하게 구성)
                    content.innerHTML = `
                        <div class="guideline-card">
                            <div class="guideline-header">
                                <h2>${title}</h2>
                            </div>
                            ${formattedSections}
                        </div>
                    `;
                    // ✅ 모달 드래그 기능 활성화 (렌더링 후 호출)
                    makeModalResizable("monthlyGuidelineContentWrapper", "resizeHandle");
                } catch (error) {
                    console.error("🚨 월간 가이드라인 호출 오류:", error);
                    content.innerHTML = `<p>⚠️ 월간 가이드라인을 불러오는 데 실패했습니다.</p>`;
                }
            });
}
        // ✅ 요소 존재 여부 확인
        const yearSelect = document.getElementById("yearSelect");
        const monthSelect = document.getElementById("monthSelect");

        if (!yearSelect || !monthSelect) {
            console.error("🚨 연도 또는 월 선택 드롭다운 요소가 존재하지 않습니다!");
            return;
        }

        // ✅ 드롭다운 초기화 (기존 옵션이 있을 경우 제거)
        if (!window.isDateSelectorsInitialized) {
            populateDateSelectors();
            window.isDateSelectorsInitialized = true;
        }

        // ✅ 현재 연도와 월을 기준으로 데이터 불러오기
        const today = new Date();
        const year = today.getFullYear();
        const month = today.getMonth() + 1;

        console.log(`📡 ${year}년 ${month}월 데이터 병렬 요청 시작...`);
        
        Promise.all([
            fetchAnomalyTrend(year, month),
            fetchAnomalyProducts(year, month),
            fetchAnomalyShoesCategory(year, month)
        ]).then(() => {
            console.log(`✅ ${year}년 ${month}월 데이터 병렬 요청 완료!`);
        }).catch(error => {
            console.error(`🚨 API 요청 중 오류 발생: ${error}`);
        });
    }
});
// ✅ 차트를 업데이트하기 전에 기존 차트 제거
// ✅ 원형 그래프 업데이트
function updateDoughnutChart(canvasId, labels, data) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels,
            datasets: [{
                data,
                backgroundColor: ['#ff4d4d', '#ffc107', '#17a2b8'],
                borderWidth: 2, // ✅ 조각 테두리 두껍게
                borderColor: '#fff' // ✅ 조각 경계 흰색으로 설정
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // ✅ 비율 고정 해제
            cutout: '40%', // ✅ 도넛 내부 구멍 크기 조정
            plugins: {
                legend: { display: true, position: 'top' },
                datalabels: {
                    color: '#fff', // ✅ 기본 흰색 텍스트
                    textStrokeColor: '#000', // ✅ 검은색 테두리 추가
                    textStrokeWidth: 2, // ✅ 테두리 두께 증가
                    font: { weight: 'bold', size: 14 },
                    formatter: (value, context) => {
                        const dataset = context.dataset.data;
                        const total = dataset.reduce((acc, num) => acc + num, 0);
                        if (total === 0) return "";
                        const percentage = ((value / total) * 100).toFixed(1);
                        return `${percentage}%`;
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}
function updateStackedSentimentChart(canvasId, todayData, weeklyData) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ["부정", "중립", "긍정"], // X축 라벨
            datasets: [
                {
                    label: "오늘",
                    data: todayData,
                    backgroundColor: ["#FF4D4D", "#8B5A2B", "#187BCD"], // 빨강, 갈색, 파랑
                    borderColor: ["#FF4D4D", "#8B5A2B", "#187BCD"],
                    borderWidth: 1
                },
                {
                    label: "이번 주",
                    data: weeklyData,
                    backgroundColor: ["rgba(255, 77, 77, 0.4)", "rgba(139, 90, 43, 0.4)", "rgba(24, 123, 205, 0.4)"], 
                    borderColor: ["rgba(255, 77, 77, 0.7)", "rgba(139, 90, 43, 0.7)", "rgba(24, 123, 205, 0.7)"],
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { 
                    stacked: true, 
                    ticks: { font: { size: 14, weight: 'bold' } }
                },
                y: { 
                    stacked: true, 
                    beginAtZero: true,
                    ticks: { font: { size: 14, weight: 'bold' } }
                }
            },
            plugins: {
                legend: { 
                    display: true, 
                    position: 'top',
                    labels: {
                        usePointStyle: true, // ● 아이콘 사용
                        generateLabels: function(chart) {
                            return chart.data.datasets.map((dataset, i) => ({
                                text: i === 0 ? "오늘" : "이번 주",
                                datasetIndex: i,
                                fillStyle: "transparent", // 색상 제거
                                strokeStyle: "black", // 텍스트 색상 유지
                                hidden: chart.isDatasetVisible(i) ? false : true,
                                lineWidth: 0
                            }));
                        }
                    },
                    onClick: function(e, legendItem, legend) {
                        const index = legendItem.datasetIndex;
                        const meta = legend.chart.getDatasetMeta(index);
                        meta.hidden = meta.hidden === null ? !legend.chart.data.datasets[index].hidden : null;
                        legend.chart.update();
                    }
                },
                datalabels: { display: false } // 숫자 제거
            }
        },
        plugins: [ChartDataLabels]
    });
}

function closeMonthlyGuidelineModal() {
  const modal = document.getElementById("monthlyGuidelineModal");
  if (modal) {
    modal.style.display = "none";
  }
}

// ✅ 제품 리스트만 표시 & 리뷰 상세보기 버튼 추가
document.addEventListener("DOMContentLoaded", async () => {
    console.log("📡 fetchAnomalySummary() 실행됨!");
    await fetchAnomalySummary();

    document.getElementById("today-btn").addEventListener("click", () => {
        console.log("✅ 오늘 이상 감지 목록 버튼 클릭됨!");
        updateAnomalyReviews("today", lastAnomalyData?.today?.anomaly_reviews || []);
        showModal("anomalyModal");
    });

    document.getElementById("weekly-btn").addEventListener("click", () => {
        console.log("✅ 이번 주 이상 감지 목록 버튼 클릭됨!");
        updateAnomalyReviews("weekly", lastAnomalyData?.weekly?.anomaly_reviews || []);
        showModal("anomalyModal");
    });
});

function showModal(modalId) {
    // ✅ 기존 모달 숨기기 (완전히 닫지 않음)
    document.getElementById("anomalyModal").style.visibility = "hidden";

    const modal = document.getElementById(modalId);
    if (!modal) {
        console.error(`🚨 모달 ID "${modalId}"을 찾을 수 없습니다.`);
        return;
    }

    console.log(`✅ ${modalId} 모달 열기`);
    modal.style.display = "block";
    modal.style.visibility = "visible";
    modal.style.opacity = "1";
    modal.style.zIndex = "9999";
}

function updateAnomalyReviews(type, reviews) {
    const modalTitle = document.getElementById("modalAnomalyTitle");
    const modalList = document.getElementById("modalAnomalyList");

    if (modalTitle.getAttribute("data-active") === type) {
        console.log(`⚠️ ${type} 모달이 이미 열려 있어 중복 업데이트 방지`);
        return;
    }

    modalTitle.setAttribute("data-active", type);
    modalTitle.innerText = type === "today" ? "오늘 이상 감지 목록" : "이번 주 이상 감지 목록";
    modalList.innerHTML = "";

    console.log(`📢 ${type} 이상 감지 리뷰 개수:`, reviews.length);

    if (!reviews || reviews.length === 0) {
        modalList.innerHTML = "<p>이상 감지된 리뷰가 없습니다.</p>";
    } else {
        // ✅ 중복 제거 (review_id + sentence 기준)
        const uniqueReviews = removeDuplicateReviews(reviews);

        const groupedReviews = uniqueReviews.reduce((acc, review) => {
            if (!acc[review.product_id]) {
                acc[review.product_id] = {
                    product_id: review.product_id,
                    product_name: review.product_name || "상품명 없음",
                    brand: review.brand || "브랜드 없음",
                    price: review.price || "가격 정보 없음",
                    image_url: review.image_url || "",
                    reviews: [],
                };
            }
            acc[review.product_id].reviews.push(review);
            return acc;
        }, {});

        Object.values(groupedReviews).forEach(product => {
    const reviewCount = product.reviews.length;

    const reviewCard = document.createElement("div");
    reviewCard.classList.add("review-card");

    reviewCard.innerHTML = `
        <img src="${product.image_url}" class="review-image">
        <div class="review-content">
            <div class="review-title product-link" data-product-id="${product.product_id}">
                ${product.product_name} (${product.brand})
            </div>
            <span class="review-meta">가격: ${product.price || "가격 정보 없음"}</span>
            <span class="review-meta">리뷰 개수: ${reviewCount}개</span>
            <div class="button-group">
                <button class="review-btn" data-product-id="${product.product_id}">리뷰 보기</button>
                <button class="review-btn guideline-btn" data-product-id="${product.product_id}">제품 이상 감지 리포트</button>
</div>
            </div>
    `;

    modalList.appendChild(reviewCard);
});

        // ✅ 제품 이름 클릭 시 상세 페이지 이동
        document.querySelectorAll(".product-link").forEach(link => {
            link.addEventListener("click", (event) => {
                const productId = event.target.getAttribute("data-product-id");
                if (productId) {
                    redirectToStrengthWeakness(productId);
                }
            });
        });

        // ✅ 리뷰 보기 버튼 클릭 이벤트 추가
        document.querySelectorAll(".review-btn").forEach(btn => {
            btn.addEventListener("click", (event) => {
                const productId = event.target.getAttribute("data-product-id");
                console.log(`✅ 리뷰 상세보기 버튼 클릭됨: Product ID = ${productId}`);

                if (!productId) {
                    console.error("🚨 오류: 클릭한 버튼에서 productId를 찾을 수 없습니다!");
                    return;
                }

                showReviewModal(productId);
            
            });
        });
        document.querySelectorAll(".guideline-btn").forEach(btn => {
            btn.addEventListener("click", async (event) => {
                const productId = event.target.getAttribute("data-product-id");
                const productName = event.target.closest(".review-content")?.querySelector(".review-title")?.innerText || "";

                // ✅ 현재 모달 상태(type: 'today' or 'weekly') 확인
                const modalType = document.getElementById("modalAnomalyTitle").getAttribute("data-active");

                // ✅ API URL 분기 처리
                const endpoint = modalType === "today"
                    ? `/api/anomaly-guideline-today/${productId}`
                    : `/api/anomaly-guideline/${productId}`;

                // ✅ 로딩 메시지
                showGuidelineModal(`🔄 ${productName} 가이드라인 생성 중입니다...`);

                try {
                    const res = await fetch(endpoint);
                    if (!res.ok) throw new Error("가이드라인 요청 실패");

                    const json = await res.json();
                    showGuidelineModal(`📝 [${productName}]\n\n${json.guideline}`);
                } catch (error) {
                    console.error("🚨 가이드라인 API 호출 오류:", error);
                    showGuidelineModal("⚠️ 가이드라인을 불러오는 데 실패했습니다. 잠시 후 다시 시도해주세요.");
                }
            });
        });
    }
}

function showGuidelineModal(guidelineText) {
    const modal = document.getElementById("guidelineModal");
    const content = document.getElementById("guidelineModalContent");

    if (!modal || !content) return;

    // ✅ 맨 위 '[무료반품]' 제거
    guidelineText = guidelineText.replace(/^\[.*?\]\s*\n*/, "").trim();

    // ✅ 제품명 추출
    const productTitleMatch = guidelineText.match(/📝\s*\[\s*([\s\S]*?)\s*\]/);
    const productTitle = productTitleMatch ? productTitleMatch[1].trim() : "제품명 없음";

    // ✅ 📝 [제품명] 제거
    let body = guidelineText.replace(/📝\s*\[\s*([\s\S]*?)\s*\]/, "").trim();

    // ✅ 기타 텍스트 클린업
    body = body
        .replace(/\*{0,2}제품\s*개선\s*가이드라인\*{0,2}/gi, "")
        .replace(/\*{1,3}(.+?)\*{1,3}/g, "$1")
        .trim();

    // ✅ 제품명이 포함된 줄 제거
    const lines = body.split("\n").filter(line => {
        const cleanLine = line.replace(/\s/g, "");
        const cleanTitle = productTitle.replace(/\s/g, "");
        return !cleanLine.includes(cleanTitle);
    });
    body = lines.join("\n").trim();

    // ✅ 섹션 나누기
    const sectionBlocks = body.split(/\n(?=\d\.\s)/g);
    const formattedSections = sectionBlocks.map(section => {
        const lines = section.trim().split("\n");
        const title = lines[0].trim();
        const content = lines.slice(1).join("<br>");
        return `
            <div class="guideline-section">
                <div class="section-title">${title}</div>
                <div class="section-content">${content}</div>
            </div>
        `;
    }).join("");

    // ✅ 최종 렌더링
    content.innerHTML = `
        <div class="guideline-card">
            <div class="guideline-header">
                <h2>${productTitle}</h2>
            </div>
            ${formattedSections}
        </div>
    `;

    modal.style.display = "block";
    modal.style.visibility = "visible";
    modal.style.opacity = "1";
    modal.style.zIndex = "9999";
}






function closeGuidelineModal() {
    const modal = document.getElementById("guidelineModal");
    if (modal) {
        modal.style.display = "none";
        modal.style.visibility = "hidden";
        modal.style.opacity = "0";
    }
}

function showReviewModal(productId) {
    if (!productId) {
        console.error("🚨 오류: showReviewModal()에서 productId가 undefined입니다!");
        return;
    }

    console.log(`📢 리뷰 상세보기 실행 (Product ID: ${productId})`);

    if (!lastAnomalyData) {
        console.error("🚨 lastAnomalyData가 비어 있음!");
        return;
    }

    const modalTitle = document.getElementById("modalReviewTitle");
    const reviewList = document.getElementById("modalReviewList");

    modalTitle.innerText = `리뷰 상세보기 (상품 ID: ${productId})`;
    reviewList.innerHTML = "<p>리뷰 데이터를 불러오는 중...</p>";

    let productReviews = [
        ...(lastAnomalyData.today.anomaly_reviews || []),
        ...(lastAnomalyData.weekly.anomaly_reviews || [])
    ].filter(review => String(review.product_id) === String(productId));

    // ✅ 중복 리뷰 제거 (review_id + sentence 기준)
    productReviews = removeDuplicateReviews(productReviews);

    if (productReviews.length === 0) {
        reviewList.innerHTML = "<p>리뷰 없음</p>";
        return;
    }

    reviewList.innerHTML = productReviews.map(review => {
        let sentimentClass = "";
        let sentimentIcon = "";

        switch (review.sentiment) {
            case 0:
                sentimentClass = "sentiment-negative";
                sentimentIcon = '<i class="fa-solid fa-face-frown" style="color: red;"></i>';
                break;
            case 1:
                sentimentClass = "sentiment-neutral";
                sentimentIcon = '<i class="fa-solid fa-meh" style="color: orange;"></i>';
                break;
            case 2:
                sentimentClass = "sentiment-positive";
                sentimentIcon = '<i class="fa-solid fa-face-smile" style="color: green;"></i>';
                break;
        }

        return `
            <div class="review-box">
                <div class="review-item"><i class="fa-solid fa-star" style="color: gold;"></i> <strong>별점:</strong> ${review.rating || "N/A"}점</div>
                <div class="review-item"><i class="fa-solid fa-comment-dots"></i> <strong>리뷰:</strong> ${review.sentence || "내용 없음"}</div>
                <div class="review-item"><i class="fa-solid fa-folder"></i> <strong>카테고리:</strong> ${review.category || "미분류"}</div>
                <div class="review-item"><i class="fa-solid fa-ruler-horizontal"></i> <strong>사이즈:</strong> ${review.review_size || "미지정"}</div>
                <div class="review-item"><i class="fa-solid fa-calendar-day"></i> <strong>작성일:</strong> ${review.review_date?.split(" ")[0] || "날짜 없음"}</div>
                <div class="review-item ${sentimentClass}">
                    <i class="fa-solid fa-chart-line"></i> <strong>감성 분석:</strong>
                    ${sentimentIcon} ${review.sentiment === 0 ? "부정 감성" : review.sentiment === 1 ? "중립 감성" : "긍정 감성"}
                </div>
            </div>
        `;
    }).join("");

    const anomalyModal = document.getElementById("anomalyModal");
    if (anomalyModal) {
        anomalyModal.style.display = "none";
    }

    showModal("reviewModal");
}




// ✅ 모달 창 닫기
function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = "none";
        modal.style.visibility = "hidden";
        modal.style.opacity = "0";
        console.log(`✅ 모달 닫힘: ${modalId}`);

        // ✅ 리뷰 모달을 닫으면 anomalyModal 다시 보이기
        if (modalId === "reviewModal") {
            const anomalyModal = document.getElementById("anomalyModal");
            if (anomalyModal) {
                anomalyModal.style.visibility = "visible";
                anomalyModal.style.display = "block";
                anomalyModal.style.opacity = "1";
            }
        }
    } else {
        console.warn(`⚠️ 모달 ID "${modalId}"을 찾을 수 없습니다.`);
    }
}


// ✅ 강/약점 분석 페이지로 이동하는 함수
function redirectToStrengthWeakness(productId) {
    window.location.href = `/strength-weakness.html?product_id=${productId}`;
}

// ✅ 카테고리별 막대 그래프 (전체 + 부정 리뷰 통합)
function updateCombinedBarChart(canvasId, labels, totalData, negativeData) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }

    console.log(`📊 [DEBUG] ${canvasId} 차트 업데이트:`);
    console.log("✅ 카테고리 리스트:", labels);
    console.log("✅ 전체 리뷰 수:", totalData);
    console.log("✅ 부정 리뷰 수:", negativeData);

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
            labels,
            datasets: [
                {
                    label: "전체 리뷰",
                    data: totalData,
                    backgroundColor: '#36a2eb'
                },
                {
                    label: "부정 리뷰",
                    data: negativeData,
                    backgroundColor: '#ff4d4d'
                }
            ]
        },
        options: {
            responsive: true,
            indexAxis: 'y',
            plugins: {
            legend: { display: true, position: 'top' },
            datalabels: {
                color: '#000',
                font: { weight: 'bold', size: 12 },
                formatter: (value) => value > 0 ? value : '',
                anchor: 'end', align: 'right', 
                clip: false  // 🚨 텍스트가 잘리지 않도록 추가
            }
        }
        },
        plugins: [ChartDataLabels]
    });
}
    // ✅ 레이더 차트 업데이트 함수
    function updateStackedAreaChart(canvasId, labels, dataset) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: dataset
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            scales: {
                y: {
                    stacked: true,
                    beginAtZero: true
                }
            },
            plugins: {
                legend: { display: true, position: 'top' },
                datalabels: {
                    anchor: 'end',
                    align: 'top',
                    color: '#000',
                    font: { weight: 'bold', size: 12 },
                    formatter: (value) => value > 0 ? value : ''
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}

function showNotification(message, review) {
    if (!review) {
        console.error("🚨 오류: 알림에 필요한 리뷰 데이터가 없습니다.");
        return;
    }

    const notificationId = `notification-${review.review_id}-${review.sentiment}`;
    if (document.getElementById(notificationId)) {
        console.warn(`⚠️ 중복 알림 방지: 리뷰 ID ${review.review_id} (${review.sentiment})`);
        return;
    }

    let anomalyType = "";
    if (review.sentiment === 0 && (review.rating === 4.0 || review.rating === 5.0)) {
        anomalyType = "🔴 [부정 감성 감지]";
    } else if (review.rating === 1.0 || review.rating === 2.0) {
        anomalyType = "🟠 [평점 감지]";
    } else {
        anomalyType = "⚠️ [일반 부정 감지]";
    }

    const notification = document.createElement("div");
    notification.classList.add("notification-popup");
    notification.id = notificationId;

    const closeButton = document.createElement("span");
    closeButton.classList.add("close-btn");
    closeButton.innerHTML = "×";
    closeButton.onclick = function () {
        notification.style.opacity = "0";
        notification.style.transform = "scale(0.95)";
        setTimeout(() => notification.remove(), 200);
    };

    notification.innerHTML = `
        <div class="title">🚨 이상 감지: 부정 리뷰 감지</div>
        <div class="anomaly-type">${anomalyType}</div>
        <div class="review">
            📌 리뷰: ${review.sentence || "내용 없음"}
        </div>
        <div class="meta-info">
            // <span>🏷️ 카테고리: ${review.category || "미분류"}</span>
            <span>⭐ 평점: ${review.rating || "N/A"}점</span>
        </div>
    `;

    notification.prepend(closeButton);

    let notificationContainer = document.getElementById("notification-container");
    if (!notificationContainer) {
        notificationContainer = document.createElement("div");
        notificationContainer.id = "notification-container";
        document.body.appendChild(notificationContainer);
    }

    notificationContainer.appendChild(notification);

    setTimeout(() => {
        notification.classList.add("show");
    }, 100);

    setTimeout(() => {
        notification.classList.remove("show");
        notification.style.transform = "scale(0.95)";
        setTimeout(() => notification.remove(), 200);
    }, 5000);
}



let reconnectInterval = 3000; // 초기 재연결 간격 (3초)
let reconnectMaxInterval = 30000; // 최대 재연결 간격 (30초)
let lastReceivedReviewId = null;
let pingInterval = null;  // ✅ Ping Interval을 전역 변수로 관리

function connectWebSocket() {
    console.log("📡 WebSocket 연결 시도...");

    const wsStatusElement = document.getElementById("ws-status");
    if (!wsStatusElement) {
        console.warn("⚠️ WebSocket 상태 표시 요소를 찾을 수 없음!");
        return;
    }

    // ✅ 이미 연결 중이면 중복 연결 방지
    if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
        console.log("✅ WebSocket이 이미 연결 중이거나 연결됨.");
        return;
    }

    try {
        socket = new WebSocket(`ws://${window.location.host}/ws`);
        console.log("✅ WebSocket 객체 생성됨:", socket);

        socket.onopen = () => {
            console.log("✅ WebSocket 연결 성공!");
            wsStatusElement.innerText = "✅ WebSocket 연결됨";
            reconnectAttempts = 0;

            // ✅ Ping 요청을 한 번만 실행 (중복 실행 방지)
            if (!pingInterval) {
                pingInterval = setInterval(() => {
                    if (socket.readyState === WebSocket.OPEN) {
                        console.log("📡 WebSocket Ping 요청 보냄...");
                        socket.send(JSON.stringify({ ping: "keep-alive" }));
                    }
                }, 300000); // 5분마다 실행
            }
        };

        socket.onmessage = (event) => {
            try {
                console.log("📩 WebSocket 메시지 수신:", event.data);

                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (e) {
                    console.warn("⚠️ WebSocket JSON 파싱 실패, 원본 메시지 사용");
                    data = event.data;
                }

                // 🔹 Keep-alive Ping 응답 처리
                if (data.ping === "keep-alive") {
                    console.log("🔄 WebSocket Ping 응답 수신");
                    return;
                }

                // 🔹 WebSocket 메시지 데이터 검증
                if (!data.alert || !data.review) {
                    console.warn("⚠️ 수신된 WebSocket 데이터가 유효하지 않음:", data);
                    return;
                }

                // ✅ 중복 메시지 필터링 (같은 review_id 연속 수신 방지)
                if (lastReceivedReviewId === data.review.review_id) {
                    console.warn(`⚠️ 중복된 WebSocket 알림 무시: ${data.review.review_id}`);
                    return;
                }
                lastReceivedReviewId = data.review.review_id;

                console.log("📢 이상 감지 알림 수신:", data.alert);
                showNotification(data.alert, data.review);
                updateNegativeReviewsList(data.review);
            } catch (error) {
                console.error("🚨 WebSocket 메시지 처리 오류:", error, "받은 데이터:", event.data);
            }
        };

        socket.onclose = () => {
            console.warn("⚠️ WebSocket 연결 종료됨. 재연결 시도...");
            wsStatusElement.innerText = "⚠️ WebSocket 연결 해제됨";

            if (reconnectAttempts >= maxReconnectAttempts) {
                console.warn("🚨 WebSocket 재연결 최대 시도 횟수 초과. 더 이상 재연결하지 않음.");
                wsStatusElement.innerText = "❌ WebSocket 연결 실패 (최대 시도 횟수 초과)";
                return;
            }

            reconnectAttempts++;
            const retryDelay = Math.min(3000 * reconnectAttempts, 30000); // 최대 30초까지 증가

            console.log(`🔄 WebSocket 재연결 시도 (${reconnectAttempts}/${maxReconnectAttempts})... 대기 시간: ${retryDelay / 1000}초`);
            reconnectTimeout = setTimeout(connectWebSocket, retryDelay);
        };

        socket.onerror = (error) => {
            console.error("🚨 WebSocket 오류 발생:", error);
            socket.close();
        };
    } catch (error) {
        console.error("🚨 WebSocket 생성 오류:", error);
    }
}
    document.addEventListener("DOMContentLoaded", async () => {
    console.log("📡 WebSocket 및 데이터 초기화...");

    // ✅ 오늘 날짜 표시
    const todayDateElement = document.getElementById("today_date");
    if (todayDateElement) {
        todayDateElement.innerText = new Date().toISOString().slice(0, 10);
    } else {
        console.warn("⚠️ today_date 요소를 찾을 수 없습니다.");
    }

    // ✅ WebSocket 연결
    console.log("🔍 connectWebSocket 함수 존재 여부:", typeof connectWebSocket);
    connectWebSocket();
    console.log("📡 강제 실행 후 WebSocket 상태:", typeof socket, socket ? socket.readyState : "WebSocket 객체 없음");
    // ✅ 이상 감지 리뷰 데이터 로드
    console.log("📡 fetchAnomalySummary() 실행됨!");
    fetchAnomalySummary();
    // ✅ 버튼 클릭 시 모달 표시 (수정됨)
    document.querySelector(".btn[data-type='today']")
        ?.addEventListener("click", () => {
            console.log("✅ 오늘 이상 감지 목록 버튼 클릭됨!");
            updateAnomalyReviews("today", lastAnomalyData?.today?.anomaly_reviews || []);
        });
        document.querySelector(".btn[data-type='weekly']")
        ?.addEventListener("click", () => {
            console.log("✅ 이번 주 이상 감지 목록 버튼 클릭됨!");
            updateAnomalyReviews("weekly", lastAnomalyData?.weekly?.anomaly_reviews || []);
        });
    setInterval(fetchAnomalySummary, 60000); // 30초마다 데이터 갱신
    
    // ✅ 차트 데이터 미리 가져오기
    const startDate = document.getElementById("startDate").value;
    const endDate = document.getElementById("endDate").value;

    // ✅ API에서 데이터 미리 로드
    const [totalSales, categorySales, genderSales] = await Promise.all([
        fetchData(`/api/total-sales?startDate=${startDate}&endDate=${endDate}`),
        fetchData(`/api/category-sales?startDate=${startDate}&endDate=${endDate}`),
        fetchData(`/api/gender-sales?startDate=${startDate}&endDate=${endDate}`)
    ]);

    // ✅ 데이터 캐싱 (로컬 변수로 저장)
    console.log("✅ 문서가 로드됨, 이상 감지 리스트 이벤트 등록 완료");
    
    // ✅ 이벤트 리스너 추가
    document.querySelector(".toggle-btn[data-type='today']")
        ?.addEventListener("click", () => toggleAnomalyList("today"));
    
    document.querySelector(".toggle-btn[data-type='weekly']")
        ?.addEventListener("click", () => toggleAnomalyList("weekly"));
    const chartData = { totalSales, categorySales, genderSales };

    // ✅ 차트 지연 로딩 설정
    const lazyCharts = document.querySelectorAll("canvas");

    const observer = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const canvasId = entry.target.id;
                console.log(`🎨 차트 로딩: ${canvasId}`);

                // ✅ API에서 불러온 데이터 전달
                if (canvasId === "totalSalesChart" && chartData.totalSales) {
                    renderTotalSalesChart(chartData.totalSales);
                }
                if (canvasId === "categorySalesChart" && chartData.categorySales) {
                    renderCategorySalesChart(chartData.categorySales);
                }
                if (canvasId === "genderSalesChart" && chartData.genderSales) {
                    renderGenderSalesChart(chartData.genderSales);
                }
                
                observer.unobserve(entry.target); // ✅ 한 번 로드한 후 더 이상 감지하지 않음
            }
        });
    }, { threshold: 0.1 });

    lazyCharts.forEach(chart => observer.observe(chart));
});

function toggleAnomalyList(type) {
    document.getElementById("today-anomaly-section").style.display = type === "today" ? "block" : "none";
    document.getElementById("weekly-anomaly-section").style.display = type === "weekly" ? "block" : "none";
}

function updateNegativeReviewsList(newReview) {
    let reviewList = document.getElementById("negative-reviews");

    // ✅ 요소가 없으면 자동 생성 후 추가
    if (!reviewList) {
        console.warn("⚠️ `negative-reviews` 요소가 없어 새로 생성합니다.");
        reviewList = document.createElement("ul");
        reviewList.id = "negative-reviews";
        document.body.appendChild(reviewList);  // ✅ body에 추가
    }

    // ✅ 중복 리뷰 방지
    if (document.getElementById(`review-${newReview.review_id}`)) {
        console.warn(`⚠️ 중복 리뷰 감지: ${newReview.review_id}`);
        return;
    }

    const listItem = document.createElement("li");
    listItem.id = `review-${newReview.review_id}`;
    listItem.innerHTML = `
        <strong>${newReview.product_name}</strong> (${newReview.brand}) - ⭐ ${newReview.rating}점<br>
        📌 ${newReview.sentence}
    `;

    reviewList.prepend(listItem);
}

function navigateTo(url) {
    window.location.href = url;
}
// ##############################################################################################################################################################################################################################
// 브랜드 분석 평가
document.addEventListener("DOMContentLoaded", async function () {
    const defaultBrand = "무신사 스탠다드"; // ✅ 기본 검색할 브랜드 지정
    document.getElementById("brand-name").value = defaultBrand;
    await fetchBrandAnalysis(); // ✅ 페이지 로드 시 기본 브랜드 검색 실행
});

async function fetchBrandAnalysis() {
    let brandName = document.getElementById("brand-name").value.trim();
    if (!brandName) {
        brandName = "무신사 스탠다드"; // ✅ 기본 브랜드 지정
    }

    console.log(`📡 브랜드 분석 요청: /api/brand-analysis/${brandName}`);

    try {
        const response = await fetch(`/api/brand-analysis/${brandName}`);
        const data = await response.json();

        if (!response.ok) {
            console.error("🚨 서버 오류 발생");
            return;
        }

        console.log("📡 서버 응답 데이터:", data); 
        updateBrandGauge(data.overall_score);  // ✅ 브랜드 종합 평가 업데이트
        displayBrandAnalysis(data); // ✅ 토픽별 만족도 & 언급량 표시
        const salesData = data.sales_data || {}; 
        renderBrandSalesChart(salesData); // ✅ 브랜드별 판매량 추이 추가

    } catch (error) {
        console.error("🔥 네트워크 오류:", error);
    }
}

// 검색 기능
document.getElementById("brand-name").addEventListener("input", async function () {
    const query = this.value.trim();
    const dropdown = document.getElementById("brand-suggestions");

    if (query.length === 0) {
        dropdown.innerHTML = "";
        return;
    }

    try {
        const response = await fetch(`/api/search-brands/?query=${query}`);
        const data = await response.json();

        dropdown.innerHTML = ""; // 기존 목록 초기화

        data.brands.forEach((brand) => {
            const option = document.createElement("div");
            option.classList.add("suggestion-item");
            option.innerText = brand;
            // 🚀 `click` 대신 `mousedown` 사용하여 한 번에 입력되도록 수정
            option.addEventListener("mousedown", async function () {
                document.getElementById("brand-name").value = brand;
                dropdown.innerHTML = ""; // 선택 후 목록 숨기기
                
                await fetchBrandAnalysis(); // 🚀 자동 검색 실행
            });
            dropdown.appendChild(option);
        });

        dropdown.style.display = data.brands.length ? "block" : "none";

    } catch (error) {
        console.error("🚨 브랜드 자동 완성 오류:", error);
    }
});

// ✅ 검색창 외부 클릭 시 자동완성 목록 숨김
document.addEventListener("click", function (event) {
    const searchContainer = document.querySelector(".search-container");
    if (!searchContainer.contains(event.target)) {
        document.getElementById("brand-suggestions").style.display = "none";
    }
});

function displayBrandAnalysis(data) {
    const scoreResults = document.getElementById("brand-score-results");
    const frequencyResults = document.getElementById("brand-frequency-results");

    scoreResults.innerHTML = "";
    frequencyResults.innerHTML = "";
    
    if (!data.topics || Object.keys(data.topics).length === 0) {
        scoreResults.innerHTML = "<p>해당 브랜드에 대한 분석 데이터가 없습니다.</p>";
        frequencyResults.innerHTML = "<p>해당 브랜드에 대한 분석 데이터가 없습니다.</p>";
        return;
    }
    Object.entries(data.topics)
        .sort((a, b) => b[1].score - a[1].score)
        .forEach(([topic, info]) => {
            addBar(scoreResults, topic, info.score, "", 100, true);
        });
    
    // ✅ "토픽별 언급량" 데이터 확인
    console.log("📊 토픽별 언급량 데이터 확인:", data.topic_sentiment);

    if (!data.topic_sentiment || Object.keys(data.topic_sentiment).length === 0) {
        console.warn("⚠️ 토픽별 언급량 데이터가 없습니다.");
        return;
    }
    
    Object.entries(data.topic_sentiment).forEach(([topic, info]) => {
        console.log(`📊 ${topic}: 긍정=${info.positive}, 중립=${info.neutral}, 부정=${info.negative}`);
        addSentimentBar(frequencyResults, topic, info.positive, info.neutral, info.negative);
    });
}


function addBar(container, label, value, text, maxValue, isSatisfaction = false) {
    const barContainer = document.createElement("div");
    barContainer.classList.add("bar-container");

    const labelDiv = document.createElement("div");
    labelDiv.classList.add("bar-label");
    labelDiv.innerHTML = `${label}`;

    const barWrapper = document.createElement("div");
    barWrapper.classList.add("bar-wrapper");

    const backgroundBar = document.createElement("div");
    backgroundBar.classList.add("background-bar");

    const bar = document.createElement("div");
    bar.classList.add("bar");

    let widthPercentage;
    if (isSatisfaction) {
        widthPercentage = ((value - 50) / (100 - 50)) * 100;
    } else {
        widthPercentage = Math.min(100, (value / maxValue) * 100);
    }

    // ✅ 0점이면 바를 표시하지 않고 배경 삭제
    if (value === 0) {
        bar.style.width = "100%"; // ✅ 보이지는 않지만 툴팁 감지를 위해 영역 유지
        bar.style.backgroundColor = "transparent"; // ✅ 시각적으로 숨김
        bar.style.minHeight = "20px"; // ✅ 높이 유지 (이벤트 감지용)

    } else {
        widthPercentage = Math.max(5, widthPercentage); // 최소 너비 5% 유지
        bar.style.width = `${widthPercentage}%`;

        if (isSatisfaction) {
            bar.style.backgroundColor = value > 92 ? "#4CAF50" : value >= 85 ? "#FFD700": "#FF5733";
        } else {
            bar.style.backgroundColor = "#888";
        }
    }

    // ✅ 점수 표시하는 텍스트
    const textElement = document.createElement("span");
    textElement.classList.add("bar-text");
    textElement.innerText = text ? text : `${value.toFixed(1)}점`;

    textElement.style.position = "absolute";
    textElement.style.right = "10px";
    textElement.style.fontWeight = "bold";
    textElement.style.color = "#333";

    if (widthPercentage < 20) {
        textElement.style.right = "5px";
        textElement.style.color = "#fff";
    }

    // **툴팁 생성**
    const tooltip = document.createElement("div");
    tooltip.classList.add("tooltip");
    tooltip.innerHTML = `<strong>${label}</strong><br>만족도: ${value.toFixed(1)}점`;

    document.body.appendChild(tooltip);

    // 마우스 이벤트 추가
    bar.addEventListener("mouseover", (event) => {
        tooltip.style.display = "block";
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY - 30 + "px";
    });

    bar.addEventListener("mousemove", (event) => {
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY - 30 + "px";
    });

    bar.addEventListener("mouseout", () => {
        tooltip.style.display = "none";
    });
    
    bar.appendChild(textElement);
    backgroundBar.appendChild(bar);
    barWrapper.appendChild(backgroundBar);
    barContainer.appendChild(labelDiv);
    barContainer.appendChild(barWrapper);
    container.appendChild(barContainer);
}

function addSentimentBar(container, label, positive, neutral, negative) {
    const barContainer = document.createElement("div");
    barContainer.classList.add("bar-container");

    const labelDiv = document.createElement("div");
    labelDiv.classList.add("bar-label");
    labelDiv.innerHTML = `${label}`;

    const barWrapper = document.createElement("div");
    barWrapper.classList.add("bar-wrapper");

    const backgroundBar = document.createElement("div");
    backgroundBar.classList.add("background-bar-sentiment");

    const total = (positive || 0) + (neutral || 0) + (negative || 0);

    // ✅ 툴팁 생성 (모든 값이 0일 때도 툴팁을 표시해야 함)
    const tooltip = document.createElement("div");
    tooltip.classList.add("tooltip");
    tooltip.innerHTML = `<strong>${label}</strong><br>긍정: ${positive}건<br>중립: ${neutral}건<br>부정: ${negative}건`;
    tooltip.style.display = "none";
    document.body.appendChild(tooltip);

    function showTooltip(event) {
        tooltip.style.display = "block";
        tooltip.style.left = `${event.pageX + 10}px`;
        tooltip.style.top = `${event.pageY - 30}px`;
    }

    function hideTooltip() {
        tooltip.style.display = "none";
    }

    // ✅ 모든 값이 0이면 회색 배경 유지 + "0건" 표시 + 툴팁 이벤트 추가
    if (total === 0) {
        backgroundBar.style.backgroundColor = "transparent"; // ✅ 배경 없음
        backgroundBar.style.width = "100%";
        backgroundBar.style.position = "relative"; // 툴팁 위치를 위해 추가

        const zeroText = document.createElement("span");
        zeroText.classList.add("zero-text");
        zeroText.innerText = "0건";
        zeroText.style.position = "absolute";
        zeroText.style.left = "50%";
        zeroText.style.top = "50%";
        zeroText.style.transform = "translate(-50%, -50%)";
        zeroText.style.color = "#FFF";
        zeroText.style.fontWeight = "900";
        zeroText.style.fontSize = "11px";

        backgroundBar.appendChild(zeroText);

        // ✅ "0건"이 있는 경우에도 툴팁이 보이도록 이벤트 추가
        backgroundBar.addEventListener("mouseover", showTooltip);
        backgroundBar.addEventListener("mousemove", showTooltip);
        backgroundBar.addEventListener("mouseout", hideTooltip);
    }

    // ✅ 비율 계산 (전체 크기 안에서 상대적인 비율 유지)
    const positiveRatio = (positive / total) * 100;
    const neutralRatio = (neutral / total) * 100;
    const negativeRatio = (negative / total) * 100;

    function createBar(color, width, value) {
        if (value === 0) return null; // ✅ 0점이면 바 자체를 생성하지 않음.

        const bar = document.createElement("div");
        bar.classList.add("bar");
        bar.style.width = `${width}%`;
        bar.style.backgroundColor = color;
        bar.style.position = "relative";

        // ✅ 텍스트 생성 (0건이면 표시하지 않음)
        if (value > 0) {
            const textElement = document.createElement("span");
            textElement.classList.add("bar-text-sentiment");
            textElement.innerText = `${value}건`;

            // ✅ 바의 중앙에 텍스트 배치
            textElement.style.position = "absolute";
            textElement.style.left = "50%";
            textElement.style.top = "50%";
            textElement.style.transform = "translate(-50%, -50%)";
            textElement.style.whiteSpace = "nowrap";
            textElement.style.color = "black";
            textElement.style.fontSize = width < 10 ? "10px" : "12px"; // 바가 작으면 글자 크기 조정
            bar.appendChild(textElement);
        }

        // ✅ 툴팁 이벤트 추가
        bar.addEventListener("mouseover", showTooltip);
        bar.addEventListener("mousemove", showTooltip);
        bar.addEventListener("mouseout", hideTooltip);

        return bar;
    }

    // ✅ 바를 순서대로 추가 (왼쪽부터 긍정 → 중립 → 부정)
    const posBar = createBar("#187BCD", positiveRatio, positive); // 파랑 (긍정)
    const neuBar = createBar("#8B5A2B", neutralRatio, neutral); // 회색 (중립)
    const negBar = createBar("#FF4D4D", negativeRatio, negative); // 빨강 (부정)

    if (posBar) backgroundBar.appendChild(posBar);
    if (neuBar) backgroundBar.appendChild(neuBar);
    if (negBar) backgroundBar.appendChild(negBar);

    barWrapper.appendChild(backgroundBar);
    barContainer.appendChild(labelDiv);
    barContainer.appendChild(barWrapper);
    container.appendChild(barContainer);
}


function updateBrandGauge(score) {
    console.log(`⚙️ [updateBrandGauge] score=${score}`);

    let fillElement = document.getElementById("brand-score-fill");
    let scoreElement = document.getElementById("brand-score-text");
    let ratingElement = document.getElementById("brand-score-rating");

    if (!fillElement || !scoreElement || !ratingElement) {
        console.error("❌ 브랜드 평가 요소를 찾을 수 없음");
        return;
    }

    if (typeof score !== "number" || isNaN(score)) {
        console.warn("⚠️ 브랜드 점수 값이 유효하지 않음, 기본값(40) 적용");
        score = 40;
    } else if (score === 0) {
        scoreElement.textContent = "아직 평가 없음";
        return;
    }

    let rating = "미흡";
    let color = "rgba(255, 99, 132, 0.7)";  // 기본값 빨간색 (미흡)

    if (score >= 80) {
        rating = "좋음";
        color = "rgba(75, 192, 92, 0.7)";  // ✅ 초록색
    } else if (score >= 60) {
        rating = "보통";
        color = "rgba(255, 206, 86, 0.7)";  // ✅ 노란색
    }

    let adjustedScore = Math.max(40, Math.min(score, 115));
    let percent = (adjustedScore - 40) / (115 - 40);
    let dashArrayValue = Math.min(percent * 251, 251);

    console.log(`🎯 [updateBrandGauge] 변환된 비율: ${percent}, stroke-dasharray: ${dashArrayValue}, color: ${color}`);

    // ✅ stroke 색상 변경
    fillElement.setAttribute("stroke", color);
    fillElement.setAttribute("stroke-dasharray", `${dashArrayValue}, 251`);
    
    scoreElement.textContent = `${score.toFixed(1)}점/100점`;
    ratingElement.textContent = rating;
}


function renderBrandSalesChart(salesData) {
    const ctx = document.getElementById("brandSalesChart").getContext("2d");
    ctx.canvas.style.maxHeight = "400px"; // ✅ 최대 높이 설정

    // ✅ 기존 차트가 존재하면 삭제
    if (window.brandSalesChart instanceof Chart) {
        window.brandSalesChart.destroy();
    }


    if (salesData && Object.keys(salesData).length > 0) {
        defaultLabels = Object.keys(salesData);
        defaultSales = Object.values(salesData);
    }

    // ✅ salesData가 없거나 빈 객체일 경우 그래프 초기화
    if (!salesData || Object.keys(salesData).length === 0) {
        console.warn("📊 판매량 데이터 없음. 그래프 초기화.");
        window.brandSalesChart = new Chart(ctx, {
            type: "line",
            data: {
                labels: [],
                datasets: [{
                    label: "연도별 리뷰 개수",
                    data: [],
                    borderColor: "rgba(255, 255, 255, 1)",
                    backgroundColor: "rgba(54, 162, 235, 0.1)",
                    borderWidth: 2,
                    pointRadius: 5,
                    pointBackgroundColor: "rgba(54, 162, 235, 1)",
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    x: { title: { display: true, text: "연도별" } },
                    y: { beginAtZero: true, title: { display: true, text: "리뷰 개수" } }
                },
                plugins: {
                    legend: { position: "top"}
                }
            }
        });
        return; // 🚀 여기서 함수 종료 (더 이상 실행할 필요 없음)
    }

    // ✅ 데이터가 있는 경우 그래프 업데이트
    const years = Object.keys(salesData);
    const sales = Object.values(salesData);

    console.log("📊 정제된 데이터:", { years, sales });

    window.brandSalesChart = new Chart(ctx, {
        type: "line",
        data: {
            labels: years,
            datasets: [{
                label: "연도별 리뷰 개수",
                data: sales,
                borderColor: "rgba(72, 209, 204, 0.7)",
                backgroundColor: "rgba(72, 209, 204, 0.2)",
                borderWidth: 2,
                pointRadius: 5,
                pointBackgroundColor: "rgba(72, 209, 204, 0.7)",
                fill: true,
                tension: 0.4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            scales: {
                x: { title: { display: true, text: "연도별" } },
                y: { beginAtZero: true, title: { display: true, text: "리뷰 개수" } }
            },
            plugins: {
                legend: { position: "top" }
            }
        }
    });
}

// ##############################################################################################################################################################################################################################
// 브랜드 분석 평가 아래 제품 검색

// 필터 옵션 창을 열고 닫는 기능을 제공
function toggleFilter(filterId) {
    const currentFilter = document.getElementById(`filter-${filterId}`);
    const allFilters = document.querySelectorAll(".filter-options");

    // 모든 필터 창 닫기
    allFilters.forEach(filter => {
        if (filter !== currentFilter) {
            filter.style.display = "none";
            filter.parentElement.classList.remove("active");
        }
    });

    // 현재 선택된 필터 토글
    const isOpen = currentFilter.style.display === "block";
    currentFilter.style.display = isOpen ? "none" : "block";
    currentFilter.parentElement.classList.toggle("active", !isOpen);
}
// 필터 선택 상태를 업데이트하고 검색 요청을 실행
function updateFilterLabel(filterId) {
    let selectElement = document.getElementById(`${filterId}-select`);
    let selectedText = "";

    if (filterId === "reviews") {
        selectedText = document.getElementById("min-reviews").value + "개 이상";
    } else if (filterId === "price") {
        const minPrice = document.getElementById("price-min").value.trim();
        const maxPrice = document.getElementById("price-max").value.trim();

        if (minPrice !== "" && maxPrice !== "") {
            selectedText = `${minPrice} ~ ${maxPrice}`;
        } else if (minPrice !== "") {
            selectedText = `${minPrice} 원 이상`;
        } else if (maxPrice !== "") {
            selectedText = `${maxPrice} 원 이하`;
        } else {
            selectedText = "최소 ~ 최대";
        }
    } else {
        selectedText = selectElement.options[selectElement.selectedIndex].text;
    }

    document.getElementById(`selected-${filterId}`).innerText = selectedText !== "전체" ? ` ${selectedText}` : "";
    // ✅ 필터 선택 후 자동 닫기 추가
    const currentFilter = document.getElementById(`filter-${filterId}`);
    currentFilter.style.display = "none";
    currentFilter.parentElement.classList.remove("active");
    // ✅ UI 업데이트 후 검색 실행
    fetchProductList();
}

async function applyAutoFilters(data) {
    try {
        const productInfo = data.product;
        if (!productInfo) return;

        // ✅ 가격 데이터 전처리: "원" 제거 + 숫자로 변환
        let priceText = productInfo.price.toString().replace(/[^0-9]/g, ""); // 숫자만 남기기
        let price = parseInt(priceText, 10); // 정수로 변환

        if (isNaN(price)) {
            console.error("❌ 가격 변환 오류: ", productInfo.price);
            return;
        }

        // ✅ 카테고리 자동 설정
        document.getElementById("category-select").value = productInfo.category;
        document.getElementById("selected-category").innerText = ` (${productInfo.category})`;

        // ✅ 성별 자동 설정
        document.getElementById("gender-select").value = productInfo.gender;
        document.getElementById("selected-gender").innerText = ` (${productInfo.gender})`;

        // ✅ 가격대 자동 설정 (0.5배 ~ 1.5배)
        const minPrice = Math.floor(price * 0.5);
        const maxPrice = Math.ceil(price * 1.5);
        document.getElementById("price-min").value = minPrice;
        document.getElementById("price-max").value = maxPrice;
        document.getElementById("selected-price").innerText = ` (${minPrice} ~ ${maxPrice} 원)`;

        // ✅ 자동으로 해당 필터를 적용하여 유사 제품 검색 실행
        fetchProductList();
    } catch (error) {
        console.error("🔥 자동 필터 설정 오류:", error);
    }
}

function scrollToProductList() {
    const productListElement = document.getElementById("product-results");
    if (!productListElement) {
        console.error("❌ 'product-results' 요소를 찾을 수 없습니다.");
        return;
    }

    // 제품 리스트 영역으로 부드럽게 스크롤
    productListElement.scrollIntoView({
        behavior: "smooth", // 부드러운 스크롤 효과
        block: "start"      // 요소를 화면 상단에 정렬
    });
}

async function fetchProductList() {
    const category = document.getElementById("category-select").value || "";
    const gender = document.getElementById("gender-select").value || "";
    let priceMin = document.getElementById("price-min").value.trim();
    let priceMax = document.getElementById("price-max").value.trim();
    const topic = document.getElementById("topic-select").value || "";
    const minReviews = document.getElementById("min-reviews").value || 0;

    // ✅ 빈 문자열("")이 API에 전달되지 않도록 수정
    priceMin = priceMin === "" ? "0" : parseInt(priceMin, 10);
    priceMax = priceMax === "" ? "99999999" : parseInt(priceMax, 10);

    // 🔍 검색 요청 URL 확인
    const requestUrl = `/api/product-search?category=${category}&gender=${gender}&price_min=${priceMin}&price_max=${priceMax}&topic=${topic}&min_reviews=${minReviews}`;
    console.log("📡 검색 요청:", requestUrl);

    try {
        const response = await fetch(requestUrl);
        const responseText = await response.text();
        console.log("🔍 검색 응답:", responseText);

        if (!response.ok) {
            console.error("🚨 검색 요청 실패!");
            return;
        }

        const data = JSON.parse(responseText);
        displayProducts(data.products);
    } catch (error) {
        console.error("🔥 제품 검색 중 오류:", error);
    }
}


// 제품 목록 데이터를 화면에 표시하는 역할
function displayProducts(products) {
    const resultsContainer = document.getElementById("product-results");
    resultsContainer.innerHTML = "";
    fetchBrandScore()
    if (!products.length) {
        resultsContainer.innerHTML = "<p>조건에 맞는 제품이 없습니다.</p>";
        return;
    }

    products.forEach(product => {
        const productDiv = document.createElement("div");
        productDiv.classList.add("product-container");

        let reviewInfo = `${product.review_count}개`;
        if (product.avg_sentiment) {
            reviewInfo += ` (${product.avg_sentiment.toFixed(1)}점)`;
        }

        let topicScores = `<span class="sentiment-score">전체 평균 감성 점수: ${product.avg_sentiment.toFixed(1)}점</span>`;
        if (Object.keys(product.filtered_topics).length > 0) {
            topicScores = "";
            Object.entries(product.filtered_topics).forEach(([topic, score]) => {
                topicScores += `<span class="sentiment-score">${topic}: ${score.toFixed(1)}점</span> `;
            });
        }

        productDiv.innerHTML = `
            <img src="${product.image_url}" class="product-image" style="cursor: pointer;" onclick="openProductDetails('${product.product_id}')" />
            <div class="product-info">
                <p><strong>
                    <span style="cursor: pointer; text-decoration: underline;" onclick="openProductDetails('${product.product_id}')">${product.product_name}</span>
                </strong></p>
                <p>가격: ${product.price}</p>
                <p>카테고리: ${product.category}</p>
                <p>브랜드: ${product.brand}</p>
                <p>리뷰 수: ${reviewInfo}</p>
            </div>
            <div class="score-container">
                ${topicScores}
            </div>
        `;

        resultsContainer.appendChild(productDiv);
    });
}    



// 특정 제품의 상세 정보를 화면에 표시
function displayProductInfo(productData) {
        if (!productData || !productData.product_name) {
            document.getElementById("product-info").style.display = "none";
            return;
        }
    
        console.log("📸 서버에서 받은 productData:", productData);  // API 응답 확인
    
        // ✅ 기본 이미지 URL
        const defaultImageUrl = "https://rahulindesign.websites.co.in/twenty-nineteen/img/defaults/product-default.png";
    
        // ✅ `image_url`이 없거나 `undefined`이면 기본 이미지 사용
        let imageUrl = productData.image_url && productData.image_url.trim() !== "" 
            ? productData.image_url 
            : defaultImageUrl;
    
        const productImage = document.getElementById("product-image");
        productImage.src = imageUrl;
        productImage.style.display = "block"; // 혹시라도 숨겨져 있으면 보이게
    
        // ✅ 이미지 로드 실패 시 기본 이미지로 변경
        productImage.onerror = function() {
            console.error("❌ 이미지 로드 실패, 기본 이미지로 대체:", imageUrl);
            this.src = defaultImageUrl;
        };
    
        document.getElementById("product-name").innerText = productData.product_name || "정보 없음";
        document.getElementById("product-price").innerText = 
            productData.price ? productData.price.toLocaleString("ko-KR") : "정보 없음";
        document.getElementById("product-gender").innerText = productData.gender || "정보 없음";
        document.getElementById("product-category").innerText = productData.category || "정보 없음";
        document.getElementById("product-brand").innerText = productData.brand || "정보 없음";
        document.getElementById("product-review-info").innerText = 
            productData.review_count 
                ? `${productData.review_count}개 (${productData.avg_rating ? productData.avg_rating.toFixed(1) + "점" : "정보 없음"})`
                : "정보 없음";
    
        document.getElementById("product-info").style.display = "block";
    }

async function fetchBrandScore() {
        const productId = document.getElementById("product-id").value.trim();
        if (!productId) {
            console.warn("⚠️ 제품 ID가 없습니다. 브랜드 점수 요청을 건너뜁니다.");
            return;
        }
    
        console.log(`📡 브랜드 점수 요청: /api/brand-analysis-kang/${productId}`);
    
        try {
            const response = await fetch(`/api/brand-analysis-kang/${productId}`);
            if (!response.ok) {
                console.error("🚨 브랜드 점수 요청 실패! 상태 코드:", response.status);
                return;
            }
    
            const data = await response.json();
            console.log("📊 [fetchBrandScore] API 응답 데이터:", data);
    
            if (!data || !data.overall_score) {
                console.warn("⚠️ 브랜드 점수 데이터가 없습니다.");
                return;
            }
    
            // ✅ API 응답 값으로 최종 업데이트
            updateBrandGauge(data.overall_score);
    
        } catch (error) {
            console.error("🔥 [fetchBrandScore] 네트워크 오류:", error);
        }
    }
        
            
    
async function fetchAnalysis() {
    const productId = document.getElementById("product-id").value.trim();
    if (!productId) {
        alert("❌ 제품 ID를 입력하세요.");
        return;
    }

    console.log(`📡 [fetchAnalysis] 요청: /api/strength-weakness/${productId}`);

    try {
        const response = await fetch(`/api/strength-weakness/${productId}`);
        
        console.log(`📡 [fetchAnalysis] 응답 상태 코드: ${response.status}`);
        
        if (!response.ok) {
            console.error("🚨 [fetchAnalysis] 서버 오류 발생! 상태 코드:", response.status);
            alert("⚠️ 서버에서 데이터를 불러오지 못했습니다. 다시 시도해주세요.");
            return;
        }
        
        const data = await response.json();
        console.log("📡 [fetchAnalysis] 서버 응답 데이터:", JSON.stringify(data, null, 2));

        if (!data || Object.keys(data).length === 0) {
            alert("⚠️ 해당 제품의 분석 데이터가 없습니다.");
            return;
        }
        
        // ✅ 기존 기능 유지
        updateGauge("overall-score-fill", "overall-score-eval", "overall-score-text", data.overall_score);
        displayResults(data);
        displayProductInfo(data.product);
        applyAutoFilters(data);

        // ✅ 새로운 기능: 분석 요약 추가
        updateCommentBox(data);

        // ✅ 리뷰 트렌드 데이터 추가 호출 (기존 유지)
        fetchReviewTrend(productId);

        // ✅ 관련 리뷰 불러오기 (기존 유지)
        fetchRelatedReviews(productId);

        // ✅ 사이즈 분석 추가 호출 (새로운 기능 추가)
        await fetchSizeAnalysis(productId);

    } catch (error) {
        console.error("🔥 [fetchAnalysis] 네트워크 오류:", error);
        alert("🚨 네트워크 오류 발생! 인터넷 연결을 확인하거나 다시 시도해주세요.");
    }
}    

function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: "smooth" // 부드럽게 이동 (애니메이션 효과)
            });
        }

        function openProductDetails(productId) {
            if (!productId) {
                alert("❌ 제품 ID가 없습니다.");
                return;
            }
        
            // ✅ `index.html`에서 클릭 시 `strength-weakness.html`로 이동 (고정된 URL 반영)
            window.location.href = `http://15.152.242.221:8000/strength-weakness.html?product_id=${productId}`;
        }
        
        // ✅ 페이지 로드 시 `product_id`가 있으면 자동 검색 실행
        document.addEventListener("DOMContentLoaded", function () {
            console.log("📊 테스트 데이터로 그래프 확인");
        
            // 📊 테스트 데이터로 리뷰 트렌드 그래프 업데이트
        
            // ✅ 필터 값 변경 시 자동 검색 실행 (초기 로드 시 실행 방지)
            let filterChangeTriggered = false;
        
            function onFilterChange() {
                if (!filterChangeTriggered) return;
                fetchProductList();
            }
        
            document.getElementById("topic-select").addEventListener("change", onFilterChange);
            document.getElementById("category-select").addEventListener("change", onFilterChange);
            document.getElementById("gender-select").addEventListener("change", onFilterChange);
            document.getElementById("price-min").addEventListener("input", onFilterChange);
            document.getElementById("price-max").addEventListener("input", onFilterChange);
            document.getElementById("min-reviews").addEventListener("input", onFilterChange);
        
            // ✅ 0.5초 후부터 필터 변경 감지 활성화 (초기 로드 방지)
            setTimeout(() => { filterChangeTriggered = true; }, 500);
        
            // ✅ URL에서 `product_id`가 있으면 `strength-weakness.html`로 자동 이동
            setTimeout(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const productId = urlParams.get("product_id");
                if (productId) {
                    window.location.href = `http://15.152.242.221:8000/strength-weakness.html?product_id=${productId}`;
                }
            }, 1000);
            
            scrollToTop();
        });
        
        
 

function getQueryParam(param) {
    let params = new URLSearchParams(window.location.search);
    return params.get(param);
}
    
    window.onload = function() {
        let productId = getQueryParam("id");
        let productIdElement = document.getElementById("product-id-display");
        
        if (productId && productIdElement) {  // ✅ 요소가 존재할 때만 실행
            productIdElement.innerText = "제품 ID: " + productId;
        }
    };

    window.onload = function() {
            let productId = getQueryParam("id");
            
            if (productId) {  
                document.getElementById("product-id").value = productId;  
                fetchAnalysis();  // 🔥 URL에서 받은 ID로 자동 검색 실행
            }
        };

// 화면 크기 변경 감지 및 요소 위치 조정 이벤트 리스너 추가
// 스크롤 및 화면 크기 변경 모두 감지하는 함수

window.addEventListener('resize', adjustFilterPosition);

function adjustFilterPosition() {
  const filterBox = document.querySelector('.search-box');
  const brandEvaluation = document.querySelector('.product-search-card');
  
  if (window.innerWidth < 2000) {
    // 화면이 작을 때: 브랜드 종합평가 아래로 필터 이동
    if (filterBox && brandEvaluation) {
      filterBox.style.position = 'static';
      brandEvaluation.prepend(filterBox); // DOM에서 위치 이동
    }
  } else {
    // 화면이 클 때: 원래 위치로 복원
    if (filterBox) {
      filterBox.style.position = 'fixed';
      document.querySelector('.chart-card').appendChild(filterBox);
    }
  }
}

// 초기 로드 시 실행
document.addEventListener('DOMContentLoaded', adjustFilterPosition);

/////////////////////////////////////////////////////////////////////////////
// 검색 버튼 클릭 이벤트에 연결


// ################################################################################
async function fetchRankings() {  
    try {
        const response = await fetch("/api/rankings");
        if (!response.ok) throw new Error(`HTTP 오류! 상태 코드: ${response.status}`);

        const data = await response.json();
        console.log("📢 API 응답 데이터:", data);

        // `undefined` 방지 처리
        const topBrands = data?.top_brands || [];
        const bottomBrands = data?.bottom_brands || [];
        const topProducts = data?.top_products || [];
        const bottomProducts = data?.bottom_products || [];

        console.log("✅ topBrands:", topBrands);
        console.log("✅ bottomBrands:", bottomBrands);
        console.log("✅ topProducts:", topProducts);
        console.log("✅ bottomProducts:", bottomProducts);

        const elements = {
            topBrands: document.getElementById("top-brands"),
            bottomBrands: document.getElementById("bottom-brands"),
            topProducts: document.getElementById("top-products"),
            bottomProducts: document.getElementById("bottom-products")
        };

        Object.entries(elements).forEach(([key, element]) => {
            if (!element) {
                console.error(`🚨 ${key} 요소를 찾을 수 없음.`);
                return;
            }
        });

        // ✅ HTML 업데이트 (클릭 이벤트에서 데이터 가져오기 쉽게 `data-*` 속성 추가)
        elements.topBrands.innerHTML = topBrands.length 
            ? topBrands.map((b, i) => 
                `<li class="ranking-item top brand-item" data-brand="${b.brand}">
                    ${i + 1}. ${b.brand} <strong>${b.overall_score}점</strong>
                </li>`).join("")
            : "<li>데이터 없음</li>";

        elements.bottomBrands.innerHTML = bottomBrands.length 
            ? bottomBrands.map((b, i) => 
                `<li class="ranking-item low brand-item" data-brand="${b.brand}">
                    ${i + 1}. ${b.brand} <strong>${b.overall_score}점</strong>
                </li>`).join("")
            : "<li>데이터 없음</li>";

        elements.topProducts.innerHTML = topProducts.length 
            ? topProducts.map((p, i) => 
                `<li class="ranking-item top product-item" data-product-id="${p.product_id}">
                    ${i + 1}. ${p.product_name} (${p.brand}) <strong>${p.overall_score}점</strong>
                </li>`).join("")
            : "<li>데이터 없음</li>";

        elements.bottomProducts.innerHTML = bottomProducts.length 
            ? bottomProducts.map((p, i) => 
                `<li class="ranking-item low product-item" data-product-id="${p.product_id}">
                    ${i + 1}. ${p.product_name} (${p.brand}) <strong>${p.overall_score}점</strong>
                </li>`).join("")
            : "<li>데이터 없음</li>";

        console.log("✅ `.ranking-item` 개수:", document.querySelectorAll('.ranking-item').length);

        // ✅ ✅ ✅ 클릭 이벤트 리스너 등록 ✅ ✅ ✅
        addBrandRankingClickEvent();
        addProductRankingClickEvent();
    } catch (error) {
        console.error("🔥 데이터 로드 오류:", error);
    }
}


// ✅ 페이지 완전히 로드된 후 실행
document.addEventListener("DOMContentLoaded", () => {
    fetchRankings();
});

// ✅ 브랜드 클릭 이벤트 추가 함수
function addBrandRankingClickEvent() {
    console.log("📡 브랜드 순위 클릭 이벤트 등록 중...");

    document.querySelectorAll("#top-brands li, #bottom-brands li").forEach(brandItem => {
        brandItem.addEventListener("click", function () {
            const brandText = this.innerText.trim();
            console.log(`📡 클릭한 브랜드 텍스트: ${brandText}`);

            // ✅ 브랜드명 정확히 추출 (정규식 보완)
            const brandNameMatch = brandText.match(/^\d+\.\s*([^0-9]+?)\s*\d+(\.\d+)?점$/);
            let brandName = brandNameMatch ? brandNameMatch[1].trim() : null;

            // ✅ 정규식에서 추출 실패 시 기본적인 공백 기준 분리
            if (!brandName) {
                const splitText = brandText.split(" ");
                if (splitText.length > 1) {
                    brandName = splitText.slice(1, -1).join(" ").trim();
                }
            }

            if (brandName) {
                console.log(`📡 브랜드 순위에서 선택됨: ${brandName}`);

                const brandInput = document.getElementById("brand-name");
                if (brandInput) {
                    brandInput.value = brandName; // 🔍 검색창에 브랜드 입력

                    // ✅ 검색창으로 스크롤 이동
                    brandInput.scrollIntoView({ behavior: "smooth", block: "center" });

                    fetchBrandAnalysis(); // 🔄 브랜드 분석 실행
                } else {
                    console.error("❌ 'brand-name' 입력 필드가 존재하지 않습니다.");
                }
            } else {
                console.error("❌ 브랜드명 추출 실패. 정규식 확인 필요!");
            }
        });
    });

    console.log("✅ 브랜드 순위 클릭 이벤트 등록 완료!");
}

// ✅ 제품 클릭 이벤트 추가 함수
function addProductRankingClickEvent() {
    console.log("📡 제품 순위 클릭 이벤트 등록 중...");

    document.querySelectorAll("#top-products li, #bottom-products li").forEach(productItem => {
        productItem.addEventListener("click", function () {
            const productId = this.getAttribute("data-product-id");
            if (productId) {
                console.log(`📡 제품 순위에서 선택됨: ${productId}`);
                redirectToStrengthWeakness(productId);
            } else {
                console.error("❌ 제품 ID를 찾을 수 없습니다.");
            }
        });
    });

    console.log("✅ 제품 순위 클릭 이벤트 등록 완료!");
}
// ✅ 브랜드/제품 순위 전환
function showRanking(type) {
    document.getElementById("brand-ranking").classList.add("hidden");
    document.getElementById("product-ranking").classList.add("hidden");

    // ✅ 선택한 섹션 보이기
    document.getElementById(`${type}-ranking`).classList.remove("hidden");

    // ✅ 버튼 활성화 상태 변경
    document.querySelectorAll(".rank-toggle-btn").forEach(btn => btn.classList.remove("active"));
    document.querySelector(`.rank-toggle-btn[onclick="showRanking('${type}')"]`).classList.add("active");
}
    </script>

</div> 

{% endblock %}
</html>